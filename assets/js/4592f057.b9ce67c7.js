"use strict";(self.webpackChunkbeanio_github_org=self.webpackChunkbeanio_github_org||[]).push([[153],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var l=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,l,a=function(e,t){if(null==e)return{};var n,l,a={},r=Object.keys(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=l.createContext({}),s=function(e){var t=l.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return l.createElement(d.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},c=l.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,d=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=s(n),c=a,k=m["".concat(d,".").concat(c)]||m[c]||p[c]||r;return n?l.createElement(k,i(i({ref:t},u),{},{components:n})):l.createElement(k,i({ref:t},u))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=c;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[m]="string"==typeof e?e:a,i[1]=o;for(var s=2;s<r;s++)i[s]=n[s];return l.createElement.apply(null,i)}return l.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9414:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var l=n(7462),a=(n(7294),n(3905));const r={id:"guide",title:"Reference Guide",sidebar_label:"Reference Guide",slug:"/reference-guide"},i=void 0,o={unversionedId:"guide",id:"guide",title:"Reference Guide",description:"&copy; 2010-2022 Kevin Seim & BeanIO contributors",source:"@site/docs/reference-guide.md",sourceDirName:".",slug:"/reference-guide",permalink:"/docs/reference-guide",draft:!1,editUrl:"https://github.com/beanio/beanio.github.io/edit/main/docs/reference-guide.md",tags:[],version:"current",frontMatter:{id:"guide",title:"Reference Guide",sidebar_label:"Reference Guide",slug:"/reference-guide"},sidebar:"someSidebar",previous:{title:"Introduction",permalink:"/docs/"}},d={},s=[{value:"1.0. Introduction",id:"10-introduction",level:2},{value:"1.1. What&#39;s new in 3.0?",id:"11-whats-new-in-30",level:3},{value:"1.2. Migrating from 2.x to 3.0",id:"12-migrating-from-2x-to-30",level:3},{value:"2.0. Getting Started",id:"20-getting-started",level:2},{value:"2.1. My First Stream",id:"21-my-first-stream",level:3},{value:"3.0. Core Concepts",id:"30-core-concepts",level:2},{value:"3.1. BeanReader",id:"31-beanreader",level:3},{value:"3.2. BeanWriter",id:"32-beanwriter",level:3},{value:"3.3. Unmarshaller",id:"33-unmarshaller",level:3},{value:"3.4. Marshaller",id:"34-marshaller",level:3},{value:"3.5. Mapping Files",id:"35-mapping-files",level:3},{value:"3.6. StreamFactory",id:"36-streamfactory",level:3},{value:"3.7. Exception Handling",id:"37-exception-handling",level:3},{value:"3.7.1. BeanReaderErrorHandler",id:"371-beanreadererrorhandler",level:4},{value:"4.0. Stream Components",id:"40-stream-components",level:2},{value:"4.1. Streams",id:"41-streams",level:3},{value:"4.1.1. CSV Streams",id:"411-csv-streams",level:4},{value:"4.1.2. Delimited Streams",id:"412-delimited-streams",level:4},{value:"4.1.3. Fixed Length Streams",id:"413-fixed-length-streams",level:4},{value:"4.1.4. XML Streams",id:"414-xml-streams",level:4},{value:"4.2. Records",id:"42-records",level:3},{value:"4.2.1. Record Identification",id:"421-record-identification",level:4},{value:"4.2.2. Record Ordering",id:"422-record-ordering",level:4},{value:"4.2.3. Record Grouping",id:"423-record-grouping",level:4},{value:"4.3. Fields",id:"43-fields",level:3},{value:"4.3.1. Field Type Conversion",id:"431-field-type-conversion",level:4},{value:"4.3.2. Custom Type Handlers",id:"432-custom-type-handlers",level:4},{value:"4.3.3. Repeating Fields",id:"433-repeating-fields",level:4},{value:"4.3.4. Fixed Length Fields",id:"434-fixed-length-fields",level:4},{value:"4.4. Constants",id:"44-constants",level:3},{value:"4.5. Segments",id:"45-segments",level:3},{value:"4.5.1. Nested Beans",id:"451-nested-beans",level:4},{value:"4.5.2. Repeating Segments",id:"452-repeating-segments",level:4},{value:"4.5.2.1. Inline Maps",id:"4521-inline-maps",level:4},{value:"4.6. Stream Validation",id:"46-stream-validation",level:3},{value:"4.6.1. Record Validation",id:"461-record-validation",level:4},{value:"4.6.2. Field Validation",id:"462-field-validation",level:4},{value:"4.7. Templates",id:"47-templates",level:3},{value:"4.8. Advanced Topics",id:"48-advanced-topics",level:3},{value:"4.8.1. Mapping Bean Objects that Span Multiple Records",id:"481-mapping-bean-objects-that-span-multiple-records",level:4},{value:"5.0. Mapping XML Streams",id:"50-mapping-xml-streams",level:2},{value:"5.1. Introduction",id:"51-introduction",level:3},{value:"5.1.1. My First XML Stream",id:"511-my-first-xml-stream",level:4},{value:"5.1.2. A Note on XML Validation",id:"512-a-note-on-xml-validation",level:4},{value:"5.2. XML Names",id:"52-xml-names",level:3},{value:"5.3. XML Namespaces",id:"53-xml-namespaces",level:3},{value:"5.4. Streams",id:"54-streams",level:3},{value:"5.5. Groups",id:"55-groups",level:3},{value:"5.6. Records",id:"56-records",level:3},{value:"5.7. Fields",id:"57-fields",level:3},{value:"5.7.1. Field Type Conversion",id:"571-field-type-conversion",level:4},{value:"5.7.2. Marshalling Null Field Values",id:"572-marshalling-null-field-values",level:4},{value:"5.8. Segments",id:"58-segments",level:3},{value:"5.8.1. Nested Beans",id:"581-nested-beans",level:4},{value:"5.8.2. Wrapped Segments",id:"582-wrapped-segments",level:4},{value:"6.0. Annotations and the Stream Builder API",id:"60-annotations-and-the-stream-builder-api",level:2},{value:"6.1. The Stream Builder API",id:"61-the-stream-builder-api",level:3},{value:"6.2. Annotations",id:"62-annotations",level:3},{value:"8.0. Configuration",id:"80-configuration",level:2},{value:"8.1. Settings",id:"81-settings",level:3},{value:"Appendix A: XML Mapping File Reference",id:"appendix-a-xml-mapping-file-reference",level:2},{value:"Ranges",id:"ranges",level:5},{value:"A.1. <code>beanio</code>",id:"a1-beanio",level:3},{value:"A.2. <code>import</code>",id:"a2-import",level:3},{value:"A.3. <code>typeHandler</code>",id:"a3-typehandler",level:3},{value:"A.4. <code>property</code>",id:"a4-property",level:3},{value:"A.5. <code>template</code>",id:"a5-template",level:3},{value:"A.6. <code>include</code>",id:"a6-include",level:3},{value:"A.7. <code>stream</code>",id:"a7-stream",level:3},{value:"A.8. <code>parser</code>",id:"a8-parser",level:3},{value:"A.9. <code>group</code>",id:"a9-group",level:3},{value:"A.10. <code>record</code>",id:"a10-record",level:3},{value:"A.11. <code>segment</code>",id:"a11-segment",level:3},{value:"A.12. <code>field</code>",id:"a12-field",level:3},{value:"Appendix B: Error Message Parameters",id:"appendix-b-error-message-parameters",level:2},{value:"Appendix C: Upgrading a 1.x Mapping File Example",id:"appendix-c-upgrading-a-1x-mapping-file-example",level:2}],u={toc:s};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,l.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"\xa9"," 2010-2022 Kevin Seim & BeanIO contributors"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Copies of this document may be made for your own use and for distribution to others, provided that you do not charge\nany fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print\nor electronically.")),(0,a.kt)("h2",{id:"10-introduction"},"1.0. Introduction"),(0,a.kt)("p",null,"BeanIO is an open source Java framework for reading and writing Java objects from a flat file, stream, or any String\ninput. BeanIO is well suited for batch processing, and currently supports XML, CSV, delimited and fixed length file\nformats. BeanIO is licensed under the ",(0,a.kt)("a",{parentName:"p",href:"http://www.apache.org/licenses/LICENSE-2.0"},"Apache 2.0 License"),"."),(0,a.kt)("h3",{id:"11-whats-new-in-30"},"1.1. What's new in 3.0?"),(0,a.kt)("p",null,"BeanIO 3.0 is the continuation of the BeanIO 2.x series. Because the original maintainer wasn't working on BeanIO\nanymore and seemed to be unreachable, we decided to fork the project and host it on GitHub Pages instead of\nbeanio.org. Version 3.0 brings new exciting features like: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"support for ",(0,a.kt)("inlineCode",{parentName:"li"},"java.time")," types such as ",(0,a.kt)("inlineCode",{parentName:"li"},"LocalDateTime")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"ZonedDateTime")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"BeanWriter")," now implements ",(0,a.kt)("inlineCode",{parentName:"li"},"AutoCloseable")," to be used in try-with-resources"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"BeanReader")," now implements ",(0,a.kt)("inlineCode",{parentName:"li"},"Closeable")," to be used in try-with-resources"),(0,a.kt)("li",{parentName:"ul"},"an ",(0,a.kt)("inlineCode",{parentName:"li"},"Automatic-Module-Name")," was added to ",(0,a.kt)("inlineCode",{parentName:"li"},"MANIFEST.MF")," for BeanIO to be compatible with the Java Platform Module System")),(0,a.kt)("h3",{id:"12-migrating-from-2x-to-30"},"1.2. Migrating from 2.x to 3.0"),(0,a.kt)("p",null,"Release 3.0 is almost backwards compatible with prior 2.x releases, with the following exceptions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a JDK 1.8+ is now required"),(0,a.kt)("li",{parentName:"ul"},"the Maven ",(0,a.kt)("inlineCode",{parentName:"li"},"groupId")," changed from ",(0,a.kt)("inlineCode",{parentName:"li"},"org.beanio")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"com.github.beanio"))),(0,a.kt)("h2",{id:"20-getting-started"},"2.0. Getting Started"),(0,a.kt)("p",null,"To get started with BeanIO, add ",(0,a.kt)("inlineCode",{parentName:"p"},"beanio.jar")," to your application's classpath."),(0,a.kt)("p",null,"In Maven projects:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n    <groupId>com.github.beanio</groupId>\n    <artifactId>beanio</artifactId>\n    <version>3.0.0.M1</version>\n</dependency>\n")),(0,a.kt)("p",null,"In Gradle projects:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-groovy"},"implementation 'com.github.beanio:beanio:3.0.0.M1'\n")),(0,a.kt)("p",null,"BeanIO requires a version 1.8 JDK or higher. In order to process XML formatted streams, BeanIO also requires an XML\nparser based on the Streaming API for XML (StAX), as specified by ",(0,a.kt)("a",{parentName:"p",href:"http://www.jcp.org/en/jsr/detail?id=173"},"JSR 173"),".\nJDK 1.6 and higher includes a StAX implementation and therefore does not require any additional libraries."),(0,a.kt)("h3",{id:"21-my-first-stream"},"2.1. My First Stream"),(0,a.kt)("p",null,"This section explores a simple example that uses BeanIO to read and write a flat file containing employee data. Let's\nsuppose the file is in CSV format and has the following record layout:"),(0,a.kt)("div",{className:"indent"},(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Position"),(0,a.kt)("th",null,"Field"),(0,a.kt)("th",null,"Format")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"First Name"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Last Name"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Job Title"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Salary"),(0,a.kt)("td",null,"Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Hire Date"),(0,a.kt)("td",null,"Date (MMDDYYYY)"))))),(0,a.kt)("p",null,"A sample file is shown below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Joe,Smith,Developer,75000,10012009\nJane,Doe,Architect,80000,01152008\nJon,Anderson,Manager,85000,03182007\n")),(0,a.kt)("p",null,"Next, let's suppose we want to read records into the following Java bean for further processing. Remember that a Java\nbean must have a default no-argument constructor and public getters and setters for all exposed properties."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n    \n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"BeanIO uses an XML configuration file, called a mapping file, to define how bean objects are bound to records. Below is\na mapping file, named ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping.xml"),", that could be used to read the sample employee file and unmarshall records\ninto ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," objects. The same mapping file can be used to write, or marshall, ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," objects to a file or output\nstream."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio xmlns="http://www.beanio.org/2012/03" \n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd">\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n    </record>\n  </stream>\n</beanio>\n')),(0,a.kt)("p",null,"To read the employee CSV file, a ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamFactory")," is used to load our mapping file and create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader"),"\ninstance. The ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," is used to unmarshall ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," objects from the file ",(0,a.kt)("inlineCode",{parentName:"p"},"employee.csv"),". (For the sake of\nbrevity, proper exception handling is not shown.)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'package example;\n\nimport org.beanio.*;\nimport java.io.*;\n\npublic class BeanReaderExample {\n    public static void main(String[] args) throws Exception {\n        // create a StreamFactory\n        StreamFactory factory = StreamFactory.newInstance();\n        // load the mapping file\n        factory.load("mapping.xml");\n        \n        // use a StreamFactory to create a BeanReader\n        try (BeanReader in = factory.createReader("employeeFile", new File("employee.csv"))) {\n            Employee employee;\n            while ((employee = (Employee) in.read()) != null) {\n                // process the employee...\n            }\n        }\n    }\n}\n')),(0,a.kt)("p",null,"To write an employee CSV file, the same ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamFactory")," class is used to create a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriter")," for\nmarshalling ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," bean objects to the file ",(0,a.kt)("inlineCode",{parentName:"p"},"employee.csv"),". In this example, the same mapping configuration file is\nused for both reading and writing an employee file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'package example;\n\nimport org.beanio.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class BeanWriterExample {\n    public static void main(String[] args) throws Exception {\n        // create a StreamFactory\n        StreamFactory factory = StreamFactory.newInstance();\n        // load the mapping file\n        factory.load("mapping.xml");\n        \n        Employee employee = new Employee();\n        employee.setFirstName("Jennifer");\n        employee.setLastName("Jones");\n        employee.setTitle("Marketing")\n        employee.setSalary(60000);\n        employee.setHireDate(new Date());\n        \n        // use a StreamFactory to create a BeanWriter\n        try (BeanWriter out = factory.createWriter("employeeFile", new File("employee.csv"))) {\n            // write an Employee object directly to the BeanWriter\n            out.write(employee);\n            out.flush();\n        }\n    }\n}\n')),(0,a.kt)("p",null,"Running ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriterExample")," produces the following CSV file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Jennifer,Jones,Marketing,60000,01012011\n")),(0,a.kt)("h2",{id:"30-core-concepts"},"3.0. Core Concepts"),(0,a.kt)("h3",{id:"31-beanreader"},"3.1. BeanReader"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/BeanReader.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.BeanReader"))," interface, shown below, is used\nto read bean objects from an input stream. The ",(0,a.kt)("inlineCode",{parentName:"p"},"read()")," method returns an unmarshalled bean object for the next record\nor group of records read from the input stream. When the end of the stream is reached, ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," is returned."),(0,a.kt)("p",null,"The method ",(0,a.kt)("inlineCode",{parentName:"p"},"setErrorHandler(...)")," can be used to register a custom error handler. If an error handler is not\nconfigured, ",(0,a.kt)("inlineCode",{parentName:"p"},"read()")," simply throws the unhandled exception."),(0,a.kt)("p",null,"The method ",(0,a.kt)("inlineCode",{parentName:"p"},"getRecordName()")," returns the name of the record (or group) mapped to the most recent bean object read from\nthe input stream, as declared in the mapping file. And ",(0,a.kt)("inlineCode",{parentName:"p"},"getLineNumber()")," returns the line number of the first record\nmapped to the most recent bean object read from the input stream. Additional information is available about records read\nfrom the stream by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"getRecordCount")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"getRecordContext"),". Please consult the API documentation for further\ninformation."),(0,a.kt)("p",null,"Before discarding a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"close()")," should be invoked to close the underlying input stream."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio;\n\npublic interface BeanReader {\n\n    public Object read() throws BeanReaderException;\n    \n    public int getLineNumber();\n    \n    public String getRecordName();\n    \n    public int getRecordCount();\n    \n    public RecordContext getRecordContext(int index); \n    \n    public int skip(int count) throws BeanReaderException;\n    \n    public void close() throws BeanReaderIOException;\n    \n    public void setErrorHandler(BeanReaderErrorHandler errorHandler);\n}\n")),(0,a.kt)("h3",{id:"32-beanwriter"},"3.2. BeanWriter"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/BeanWriter.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.BeanWriter"))," interface, shown below, is used\nto write bean objects to an output stream. Calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"write(Object)")," method marshals a bean object to the output\nstream. In some cases where multiple record types are not discernible by class type or record identifying fields,\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"write(String,Object)")," method can be used to explicitly name the record type to marshal."),(0,a.kt)("p",null,"Before discarding a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriter"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"close()")," should be invoked to close the underlying output stream."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio;\n\npublic interface BeanWriter {\n\n    public void write(Object bean) throws BeanWriterException;\n    \n    public void write(String recordName, Object bean) throws BeanWriterException;\n    \n    public void flush() throws BeanWriterIOException;\n    \n    public void close() throws BeanWriterIOException;\n}\n")),(0,a.kt)("h3",{id:"33-unmarshaller"},"3.3. Unmarshaller"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/Unmarshaller.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.Unmarshaller"))," interface, shown below, is\nused to unmarshal a bean object from a ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," record."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio;\n\npublic interface Unmarshaller {\n\n    // For all stream formats\n    public Object unmarshal(String record) throws BeanReaderException;\n    \n    // For CSV and delimited formatted streams\n    public Object unmarshal(List<String> fields) throws BeanReaderException;\n    public Object unmarshal(String[] fields) throws BeanReaderException;\n\n    // For XML formatted streams\n    public Object unmarshal(Node node) throws BeanReaderException;\n    \n    public String getRecordName();\n    \n    public RecordContext getRecordContext();\n}\n")),(0,a.kt)("h3",{id:"34-marshaller"},"3.4. Marshaller"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/Marshaller.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.Marshaller"))," interface, shown below, is used\nto marshal a bean object into a ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," record."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio;\n\npublic interface Marshaller {\n\n    public Marshaller marshal(Object bean) throws BeanWriterException;\n    \n    public Marshaller marshal(String recordName, Object bean) throws BeanWriterException;\n    \n    // For all stream formats\n    public String toString();\n    \n    // For CSV and delimited formatted streams\n    public String[] toArray() throws BeanWriterException;\n    public List<String> toList() throws BeanWriterException;\n    \n    // For XML formatted streams\n    public Document toDocument() throws BeanWriterException;\n}\n")),(0,a.kt)("p",null,"Marshalling a single bean object to record text is now as simple as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"String recordText = marshaller.marshal(object).toString();\n")),(0,a.kt)("h3",{id:"35-mapping-files"},"3.5. Mapping Files"),(0,a.kt)("p",null,"BeanIO uses XML configuration files, called mapping files, to bind a stream layout to bean objects. Multiple layouts can\nbe configured in a single mapping file using ",(0,a.kt)("inlineCode",{parentName:"p"},"stream")," elements. Each stream is assigned a unique name for referencing\nthe layout. In addition to its name, every stream must declare its format using the ",(0,a.kt)("inlineCode",{parentName:"p"},"format")," attribute. Supported stream\nformats include ",(0,a.kt)("inlineCode",{parentName:"p"},"csv"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"delimited"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"fixedlength"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"xml"),". Mapping files are fully explained in the next\nsection (",(0,a.kt)("a",{parentName:"p",href:"#TheMappingFile"},"4.0. The Mapping File"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio xmlns="http://www.beanio.org/2012/03" \n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd">\n\n  <stream name="stream1" format="csv"... >\n    \x3c!-- record layout... --\x3e\n  </stream>\n  \n  <stream name="stream2" format="fixedlength"... >\n    \x3c!-- record layout... --\x3e\n  </stream>\n    \n</beanio>\n')),(0,a.kt)("h3",{id:"36-streamfactory"},"3.6. StreamFactory"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/StreamFactory.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.StreamFactory"))," class is used to load\nmapping files and create ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriter"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Marshaller")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Unmarshaller")," instances. The following code\nsnippet shows how to instantiate a ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamFactory"),", load a mapping file and create the various BeanIO parsers.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"load(...)")," method loads mapping files from the file system (relative to the current working directory), while the\nmethod ",(0,a.kt)("inlineCode",{parentName:"p"},"loadResource(...)")," loads mapping files from the classpath."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// create a StreamFactory\nStreamFactory factory = StreamFactory.newInstance();\n// load \'mapping-1.xml\' from the current working directory\nfactory.load("mapping-1.xml");\n// load \'mapping-2.xml\' from the classpath\nfactory.loadResource("mapping-2.xml");\'\n\n// create a BeanReader to read from \'in.txt\'\nReader in = new BufferedReader(new FileReader("in.txt"));\nBeanReader beanReader = factory.createReader("streamName", in);\n\n// create a BeanWriter to write to \'out.txt\'\nWriter out = new BufferedWriter(new FileWriter("out.txt"));\nBeanWriter beanWriter = factory.createWriter("streamName", out);\n\n// create an Unmarshaller to unmarshal bean objects from record text\nUnmarshaller unmarshaller = factory.createUnmarshaller("streamName");\n\n// create a Marshaller to marshal bean objects to record text\nMarshaller marshaller = factory.createMarshaller("streamName");\n')),(0,a.kt)("h3",{id:"37-exception-handling"},"3.7. Exception Handling"),(0,a.kt)("p",null,"All BeanIO exceptions extend from ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanIOException"),", which extends from ",(0,a.kt)("inlineCode",{parentName:"p"},"RuntimeException")," so that exceptions do not\nneed to be explicitly caught unless desired. ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderException")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriterException")," extend\nfrom ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanIOException")," and may be thrown by a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriter")," respectively."),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderException")," is further broken down into the following subclasses thrown by the ",(0,a.kt)("inlineCode",{parentName:"p"},"read()")," method."),(0,a.kt)("div",{className:"indent"},(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Exception"),(0,a.kt)("th",null,"Description")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReaderIOException")),(0,a.kt)("td",null,"Thrown when the underlying input stream throws an ",(0,a.kt)("code",null,"IOException"),".")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"MalformedRecordException")),(0,a.kt)("td",null,"Thrown when the underlying input stream is malformed based on the configured stream format, and therefore a record could not be accurately read from the stream.  In many cases, further reads from the input stream will be unsuccessful.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"UnidentifiedRecordException")),(0,a.kt)("td",null,"Thrown when a record does not match any record definition configured in the mapping file.  If the stream layout does not strictly enforce record sequencing, further reads from the input stream are likely to be successful.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"UnexpectedRecordException")),(0,a.kt)("td",null,"Thrown when a record is read out of order.  Once record sequencing is violated, further reads from the input stream are likely to be unsuccessful.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"InvalidRecordException")),(0,a.kt)("td",null,"Thrown when a record is matched, but the record is invalid for one of the following reasons:",(0,a.kt)("ul",null,(0,a.kt)("li",null,"A record level validation failed"),(0,a.kt)("li",null,"One or more field level validations failed"),(0,a.kt)("li",null,"Field type conversion failed")),"This exception has no effect on the state of the ",(0,a.kt)("code",null,"BeanReader")," and further reads from the input stream can be safely performed.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"InvalidRecordGroupException")),(0,a.kt)("td",null,"Extends from ",(0,a.kt)("code",null,"InvalidRecordException")," and is thrown when one or more records in a group (that are mapped to a single bean object) are invalid.  This exception has no effect on the state of the ",(0,a.kt)("code",null,"BeanReader")," and further reads from the input stream can be safely performed.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReaderException")),(0,a.kt)("td",null,"Thrown directly in a few rare unrecoverable scenarios."))))),(0,a.kt)("p",null,"When a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderException")," is thrown, information about the failed record(s) can be accessed by\ncalling ",(0,a.kt)("inlineCode",{parentName:"p"},"exception.getRecordContext()")," to obtain a ",(0,a.kt)("inlineCode",{parentName:"p"},"org.beanio.RecordContext"),". Please refer to the API javadocs for more\ninformation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio;\n\npublic interface RecordContext {\n    public int getLineNumber();\n    public String getRecordText();\n    public String getRecordName();\n    public boolean hasErrors();\n    public boolean hasRecordErrors();\n    public Collection<String> getRecordErrors();\n    public String getFieldText(String fieldName);\n    public String getFieldText(String fieldName, int index);\n    public boolean hasFieldErrors();\n    public Map<String, Collection<String>> getFieldErrors();\n    public Collection<String> getFieldErrors(String fieldName);\n}\n")),(0,a.kt)("h4",{id:"371-beanreadererrorhandler"},"3.7.1. BeanReaderErrorHandler"),(0,a.kt)("p",null,"If you need to handle an exception and continue processing, it may be simpler to register a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderErrorHandler"),"\nusing the ",(0,a.kt)("inlineCode",{parentName:"p"},"beanReader.setErrorHandler()")," method. The ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderErrorHandler")," interface is shown below. Any exception\nthrown by the error handler will be rethrown by the ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio;\n\npublic interface BeanReaderErrorHandler {\n    public void handleError(BeanReaderException ex) throws Exception;\n}\n")),(0,a.kt)("p",null,"The following example shows how invalid records could be written to a reject file by registering an error handler\nextending ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderErrorHandlerSupport"),", a subclass of ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderErrorHandler"),". All other exceptions are left\nuncaught and will bubble up to the calling method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"    BeanReader input;\n    BufferedWriter rejects;\n    try {\n        input.setErrorHandler(new BeanReaderErrorHandlerSupport() {\n            public void invalidRecord(InvalidRecordException ex) throws Exception {\n                // if a bean object is mapped to a record group,\n                // the exception may contain more than one record\n                for (int i=0, j=ex.getRecordCount(); i<j; i++) {\n                    rejects.write(ex.getRecordContext(i).getRecordText());\n                    rejects.newLine();\n                }\n            }\n        });\n        \n        Object record = null;\n        while ((record = input.read()) != null) {\n            // process a valid record\n        }\n        \n        rejects.flush();\n    }\n    finally {\n        input.close();\n        rejects.close();\n    }\n")),(0,a.kt)("h2",{id:"40-stream-components"},"4.0. Stream Components"),(0,a.kt)("p",null,"This section covers the basic components used by BeanIO to map an input stream or String to Java objects. All examples\nare shown using a mapping file, but the concepts (and most attributes) are the same whether using the stream builder\nAPI, mapping file, Java annotations, or any combination thereof."),(0,a.kt)("h3",{id:"41-streams"},"4.1. Streams"),(0,a.kt)("p",null,"A typical mapping file contains one or more stream layouts. A ",(0,a.kt)("inlineCode",{parentName:"p"},"stream")," must have a ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"format")," attribute\nconfigured. The name of the stream is used to reference the layout when creating a parser using a ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamFactory"),". And\nthe format instructs BeanIO how to interpret the stream. Supported formats include ",(0,a.kt)("inlineCode",{parentName:"p"},"xml"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"csv"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"delimited"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"fixedlength"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio xmlns="http://www.beanio.org/2012/03" \n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd">\n\n  <stream name="stream1" format="csv"... >\n    \x3c!-- record layout... --\x3e\n  </stream>\n  \n  <stream name="stream2" format="fixedlength"... >\n    \x3c!-- record layout... --\x3e\n  </stream>\n    \n</beanio>\n')),(0,a.kt)("p",null,"BeanIO parses (and formats) a record from a stream or text using a record parser generated by a ",(0,a.kt)("inlineCode",{parentName:"p"},"RecordParserFactory"),".\nBeanIO allows you to create and customize your own ",(0,a.kt)("inlineCode",{parentName:"p"},"RecordParserFactory"),", but in most cases you can simply configure\nBeanIO's default record parser factory using a stream's ",(0,a.kt)("inlineCode",{parentName:"p"},"parser")," element. The ",(0,a.kt)("inlineCode",{parentName:"p"},"parser")," element allows you to set format\nspecific properties on a ",(0,a.kt)("inlineCode",{parentName:"p"},"RecordParserFactory"),". For example, the following stream layout changes the delimiter to a pipe\nfor the delimited stream 's1':"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio xmlns="http://www.beanio.org/2012/03" \n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd">\n\n  <stream name="s1" format="delimited">\n    <parser>\n      <property name="delimiter" value="|" />\n    </parser>\n    \x3c!-- record layout... --\x3e\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("p",null,"The next few sections list available parser properties for each stream format."),(0,a.kt)("h4",{id:"411-csv-streams"},"4.1.1. CSV Streams"),(0,a.kt)("p",null,"CSV formatted streams are parsed according to ",(0,a.kt)("a",{parentName:"p",href:"http://www.ietf.org/rfc/rfc4180.txt"},"RFC 4180")," with one exception:\nmulti-line records are disabled (but this can be overridden)."),(0,a.kt)("p",null,"The following properties can be used to customize default CSV parsers:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Property Name"),(0,a.kt)("th",null,"Type"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Affects")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"delimiter")),(0,a.kt)("td",null,"char"),(0,a.kt)("td",null,"The field delimiter.  Defaults to a comma."),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"quote")),(0,a.kt)("td",null,"char"),(0,a.kt)("td",null,'The quotation mark character used to wrap fields containing a delimiter character, a quotation mark, or new lines.  Defaults to the double quotation mark, ".'),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"escape")),(0,a.kt)("td",null,"Character"),(0,a.kt)("td",null,'The character used to escape a quotation mark in a quoted field.  Defaults to the double quotation mark, ".'),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"comments")),(0,a.kt)("td",null,"String[]"),(0,a.kt)("td",null,"A comma separated list of values for identifying commented lines.  If a line read from an input stream begins with any of the configured values, the line is ignored.  A backslash may be used to escape a comma and itself.  All whitespace is preserved.",(0,a.kt)("p",null,"Enabling comments require the input reader passed to ",(0,a.kt)("code",null,"StreamFactory")," to support marking. Among others, Java's ",(0,a.kt)("code",null,"BufferedReader")," and ",(0,a.kt)("code",null,"StringReader")," support marking.")),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"multilineEnabled")),(0,a.kt)("td",null,"boolean"),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", quoted fields may contain new line characters.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"whitespaceAllowed")),(0,a.kt)("td",null,"boolean"),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", whitespace is ignored and allowed before and after quoted values.  For example, the following is allowed:",(0,a.kt)("pre",null,'Jennifer, "Jones" ,24'),"Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader, Unmarshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"unquotedQuotesAllowed")),(0,a.kt)("td",null,"boolean"),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", field text containing quotation marks do not need to be quoted unless the field text starts with a quotation mark.  For example, the following is allowed:",(0,a.kt)("pre",null,'Jennifer,She said "OK"'),"Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader, Unmarshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"recordTerminator")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"The character used to signify the end of a record.  By default, any new line character (line feed (LF), carriage return (CR), or CRLF combination) is accepted when reading an input stream, and ",(0,a.kt)("code",null,'System.getProperty("line.separator")')," is used when writing to a stream."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"alwaysQuote")),(0,a.kt)("td",null,"boolean"),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", field text is always quoted.  By default, a field is only quoted if it contains a delimeter, a quotation mark or new line characters."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))))),(0,a.kt)("h4",{id:"412-delimited-streams"},"4.1.2. Delimited Streams"),(0,a.kt)("p",null,"The default delimited parsers can be customized using the following properties:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Property Name"),(0,a.kt)("th",null,"Type"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Affects")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"delimiter")),(0,a.kt)("td",null,"char"),(0,a.kt)("td",null,"The field delimiter.  Defaults to the tab character."),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"escape")),(0,a.kt)("td",null,"Character"),(0,a.kt)("td",null,"The escape character allowed to escape a delimiter or itself.  By default, escaping is disabled."),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lineContinuationCharacter")),(0,a.kt)("td",null,"Character"),(0,a.kt)("td",null,"If this character is the last character before a new line or carriage return is read, the record will continue reading from the next line.  By default, line continuation is disabled."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"recordTerminator")),(0,a.kt)("td",null,"Character"),(0,a.kt)("td",null,"The character used to signify the end of a record.  By default, any new line character (line feed (LF), carriage return (CR), or CRLF combination) is accepted when reading an input stream, and ",(0,a.kt)("code",null,'System.getProperty("line.separator")')," is used when writing to a stream."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader, BeanWriter"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"comments")),(0,a.kt)("td",null,"String[]"),(0,a.kt)("td",null,"A comma separated list of values for identifying commented lines.  If a line read from an input stream begins with any of the configured values, the line is ignored.  A backslash may be used to escape a comma and itself.  All whitespace is preserved.",(0,a.kt)("p",null,"Enabling comments require the input reader passed to ",(0,a.kt)("code",null,"StreamFactory")," to support marking. Among others, Java's ",(0,a.kt)("code",null,"BufferedReader")," and ",(0,a.kt)("code",null,"StringReader")," support marking.")),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader"))))),(0,a.kt)("h4",{id:"413-fixed-length-streams"},"4.1.3. Fixed Length Streams"),(0,a.kt)("p",null,"The default fixed length parsers can be customized using the following properties:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Property Name"),(0,a.kt)("th",null,"Type"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Affects")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lineContinuationCharacter")),(0,a.kt)("td",null,"Character"),(0,a.kt)("td",null,"If this character is the last character before a new line or carriage return is read, the record will continue reading from the next line.  By default, line continuation is disabled."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"recordTerminator")),(0,a.kt)("td",null,"Character"),(0,a.kt)("td",null,"The character used to signify the end of a record.  By default, any new line character (line feed (LF), carriage return (CR), or CRLF combination) is accepted when reading an input stream, and ",(0,a.kt)("code",null,'System.getProperty("line.separator")')," is used when writing to a stream."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader, BeanWriter"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"comments")),(0,a.kt)("td",null,"String[]"),(0,a.kt)("td",null,"A comma separated list of values for identifying commented lines.  If a line read from an input stream begins with any of the configured values, the line is ignored.  A backslash may be used to escape a comma and itself.  All whitespace is preserved.",(0,a.kt)("p",null,"Enabling comments require the input reader passed to ",(0,a.kt)("code",null,"StreamFactory")," to support marking. Among others, Java's ",(0,a.kt)("code",null,"BufferedReader")," and ",(0,a.kt)("code",null,"StringReader")," support marking.")),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanReader"))))),(0,a.kt)("h4",{id:"414-xml-streams"},"4.1.4. XML Streams"),(0,a.kt)("p",null,"The default XML parsers can be customized using the following properties:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Property Name"),(0,a.kt)("th",null,"Type"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Affects")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"suppressHeader")),(0,a.kt)("td",null,"boolean"),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", the XML header is suppressed in the marshalled document.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"version")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"The XML header version.  Defaults to ",(0,a.kt)("code",null,"1.0"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"encoding")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"The XML header encoding.  Defaults to",(0,a.kt)("code",null,"utf-8"),'.  Note that this setting has no bearing on the actual encoding of the output stream.  If set to "", an encoding attribute is not included in the header.'),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"namespaces")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"A space delimited list of XML prefixes and namespaces to declare on the root element of a marshalled document.  The property value should be formatted as",(0,a.kt)("pre",{className:"indent"},"prefix1 namespace1 prefix2 namespace2...")),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"indentation")),(0,a.kt)("td",null,"Integer"),(0,a.kt)("td",null,"The number of spaces to indent each level of XML.  By default, indentation is disabled using a value of -1."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lineSeparator")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"The character(s) used to separate lines when indentation is enabled. By default, ",(0,a.kt)("code",null,'System.getProperty("line.separator")')," is used."),(0,a.kt)("td",null,(0,a.kt)("code",null,"BeanWriter, Marshaller"))))),(0,a.kt)("h3",{id:"42-records"},"4.2. Records"),(0,a.kt)("p",null,"Each record type read from an input stream or written to an output stream must be mapped using a ",(0,a.kt)("inlineCode",{parentName:"p"},"record")," element. A\nstream mapping must include at least one record. A record mapping is used to validate the record and bind field values\nto a bean object. A simple record configuration is shown below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="stream1" format="csv">\n    <record name="record1" class="example.Record">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="age" />\n    </record>\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("p",null,"In this example, a CSV formatted stream is mapped to a single record composed of three fields: first name, last name and\nage. When a record is read from a stream using a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader"),", the class ",(0,a.kt)("inlineCode",{parentName:"p"},"example.Record")," is instantiated and\nits ",(0,a.kt)("inlineCode",{parentName:"p"},"firstName"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"lastName")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"age")," attributes are set using standard Java bean setter naming conventions (\ne.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"setFirstName(String)"),")."),(0,a.kt)("p",null,"Similarly, when a ",(0,a.kt)("inlineCode",{parentName:"p"},"example.Record")," bean object is written to an output stream using a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanWriter"),", its ",(0,a.kt)("inlineCode",{parentName:"p"},"firstName"),"\n, ",(0,a.kt)("inlineCode",{parentName:"p"},"lastName")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"age")," attributes are retrieved from the bean object using standard Java bean getter naming\nconventions (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"getFirstName()"),")."),(0,a.kt)("p",null,"BeanIO also supports Map based records by setting a record's ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," attribute to ",(0,a.kt)("inlineCode",{parentName:"p"},"map"),", or to the fully qualified class\nname of any class assignable to ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Map"),". Note that if you plan to use Map based records, field types may need be\nexplicitly configured using the ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," attribute, or BeanIO will assume the field is of type ",(0,a.kt)("inlineCode",{parentName:"p"},"java.lang.String"),"\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," attribute is further explained in section ",(0,a.kt)("a",{parentName:"p",href:"#FieldTypeConversion."},"4.6. Field Type Conversion"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="stream1" format="csv">\n    <record name="record1" class="map">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="age" type="int"/>\n    </record>\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("h4",{id:"421-record-identification"},"4.2.1. Record Identification"),(0,a.kt)("p",null,"Oftentimes, a stream is made up of multiple record types. A typical batch file may include one header, one trailer, and\nzero to many detail records. BeanIO allows a record to be identified by one or more of its fields using expected literal\nvalues or regular expressions. If desired, BeanIO can be used to validate the order of all records in the input stream."),(0,a.kt)("p",null,"To see how a stream can be configured to handle multiple record types, let's modify our Employee file to include a\nheader and trailer record as shown below. Each record now includes a record type field that identifies the type of\nrecord."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Header,01012011\nDetail,Joe,Smith,Developer,75000,10012009\nDetail,Jane,Doe,Architect,80000,01152008\nDetail,Jon,Anderson,Manager,85000,03182007\nTrailer,3\n")),(0,a.kt)("p",null,"The mapping file can now be updated as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="header" minOccurs="1" maxOccurs="1" class="example.Header">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" format="MMddyyyy" />\n    </record>\n    <record name="employee" minOccurs="0" maxOccurs="unbounded" class="example.Employee">\n      <field name="recordType" rid="true" literal="Detail" />\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n    </record>\n    <record name="trailer" minOccurs="1" maxOccurs="1" class="example.Trailer">\n      <field name="recordType" rid="true" literal="Trailer" />\n      <field name="recordCount" />\n    </record>  \n  </stream>\n  \n</beanio>\n')),(0,a.kt)("p",null,"There are several new record and field attributes introduced in this mapping file, so we'll explain each new attribute\nin turn."),(0,a.kt)("p",null,"First, a field used to identify a record must be configured as a ",(0,a.kt)("em",{parentName:"p"},"record identifier")," using ",(0,a.kt)("inlineCode",{parentName:"p"},'rid="true"'),". There is no\nlimitation to the number of fields that can be used to identify a record, but all fields where ",(0,a.kt)("inlineCode",{parentName:"p"},'rid="true"')," must be\nsatisfied before a record is identified. If there is no field configured as a record identifier, by default the record\nwill always match."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'    <record name="header" minOccurs="1" maxOccurs="1" class="example.Header">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" />\n    </record>\n')),(0,a.kt)("p",null,"Second, all record identifying fields must have a matching validation rule configured. In our example, the literal\nvalue ",(0,a.kt)("inlineCode",{parentName:"p"},"Header")," in the record type field is used to identify the header record. Literal values must match exactly and can\nbe configured using the ",(0,a.kt)("inlineCode",{parentName:"p"},"literal")," field attribute. Alternatively, record identifying fields may use a regular expression\nto match field text using the ",(0,a.kt)("inlineCode",{parentName:"p"},"regex")," field attribute."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'    <record name="header" minOccurs="1" maxOccurs="1" class="example.Header">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" />\n    </record>\n')),(0,a.kt)("p",null,"Third, each record defines the minimum and maximum number of times it may repeat using the attributes ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs"),". Based on our configuration, exactly one header and trailer record is expected, while the number of\ndetail records is unbounded."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'    <record name="header" minOccurs="1" maxOccurs="1" class="example.Header">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" />\n    </record>\n')),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," and/or ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," are not set, the minimum occurrences of a record defaults to 0 and maximum occurrences\nis unbounded."),(0,a.kt)("p",null,"Its also possible to identify delimited and fixed length records based on their length. The ",(0,a.kt)("inlineCode",{parentName:"p"},"ridLength")," record attribute\ncan be used to specify a range of lengths to identify the record."),(0,a.kt)("h4",{id:"422-record-ordering"},"4.2.2. Record Ordering"),(0,a.kt)("p",null,"As explained in the previous section, a stream can support multiple record types. By default, a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," will read\nrecords in any order. But if desired, BeanIO can enforce record ordering using an ",(0,a.kt)("inlineCode",{parentName:"p"},"order")," attribute on each record.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"order")," attribute can be assigned any positive integer value greater than 0. Records that are assigned the same\nnumber may be read from the stream in any order. If ",(0,a.kt)("inlineCode",{parentName:"p"},"order")," is set for one record, it must be set for all other\nrecords (and groups) that share the same parent."),(0,a.kt)("p",null,"In our previous example, if we want enforce that the header record is the first record in the file, the trailer is the\nlast, and all detail records appear in the middle, the mapping file could be changed as follows. Using this\nconfiguration, if a detail record were to appear before the header record, the ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," will throw\nan ",(0,a.kt)("inlineCode",{parentName:"p"},"UnexpectedRecordException")," when the detail record is read out of order."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="header" order="1" minOccurs="1" maxOccurs="1" class="example.Header">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" format="MMddyyyy" />\n    </record>\n    <record name="employee" order="2" minOccurs="0" maxOccurs="unbounded" class="example.Employee">\n      <field name="recordType" rid="true" literal="Detail" />\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n    </record>\n    <record name="trailer" order="3" minOccurs="1" maxOccurs="1" class="example.Trailer">\n      <field name="recordType" rid="true" literal="Trailer" />\n      <field name="recordCount" />\n    </record>  \n  </stream>\n  \n</beanio>\n')),(0,a.kt)("h4",{id:"423-record-grouping"},"4.2.3. Record Grouping"),(0,a.kt)("p",null,"In some cases, a stream may be further divided into batches or groups of records. Continuing with our employee file,\nlets suppose employee detail records are batched by department, where each group of employees has a department header\nand a department trailer record. Thus an input file may look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Header,01012011\nDeptHeader,Development\nDetail,Joe,Smith,Developer,75000,10012009\nDetail,Jane,Doe,Architect,80000,01152008\nDeptTrailer,2\nDeptHeader,Product Management\nDetail,Jon,Anderson,Manager,85000,03182007\nDeptTrailer,1\nTrailer,2\n")),(0,a.kt)("p",null,"BeanIO allows you to define groups of records using a ",(0,a.kt)("inlineCode",{parentName:"p"},"group")," element to wrap the record types that belong to the group.\nGroups support the same ",(0,a.kt)("inlineCode",{parentName:"p"},"order"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," attributes, although there meaning is applied to the\nentire group. Once a record type is matched that belongs to a group, all other records in that group where ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs"),"\nis greater that 1, must be read from the stream before the group may repeat or a different record can be read. Our\nmapping file would now look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="header" order="1" minOccurs="1" maxOccurs="1" class="example.Header">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" format="MMddyyyy" />\n    </record>\n    <group name="departmentGroup" order="2" minOccurs="0" maxOccurs"unbounded">\n      <record name="deptHeader" order="1" minOccurs="1" maxOccurs="1" class="example.DeptHeader">\n        <field name="recordType" rid="true" literal="DeptHeader" />\n        <field name="departmentName" />\n      </record>\n      <record name="employee" order="2" minOccurs="0" maxOccurs="unbounded" class="example.Employee">\n        <field name="recordType" rid="true" literal="Detail" />\n        <field name="firstName" />\n        <field name="lastName" />\n        <field name="title" />\n        <field name="salary" />\n        <field name="hireDate" format="MMddyyyy" />\n      </record>\n      <record name="deptTrailer" order="3" minOccurs="1" maxOccurs="1" class="example.DeptTrailer">\n        <field name="recordType" rid="true" literal="DeptTrailer" />\n        <field name="employeeCount" />\n      </record>  \n    </group>\n    <record name="trailer" order="3" minOccurs="1" maxOccurs="1" class="example.Trailer">\n      <field name="recordType" rid="true" literal="Trailer" />\n      <field name="departmentCount" />\n    </record>  \n  </stream>\n  \n</beanio>\n')),(0,a.kt)("p",null,"The stream definition itself is a record group with defaults ",(0,a.kt)("inlineCode",{parentName:"p"},'minOccurs="0"')," and ",(0,a.kt)("inlineCode",{parentName:"p"},'maxOccurs="1"'),". If you want\nyour ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," to throw an exception if the stream is empty, simply change ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", or if you want to\nallow the entire stream to repeat indefinitely, simply change ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"unbounded")," as shown below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv" minOccurs="1" maxOccurs="unbounded">\n    \x3c!-- Record layout... --\x3e\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("h3",{id:"43-fields"},"4.3. Fields"),(0,a.kt)("p",null,"A record is made up of one or more fields, which are validated and bound to bean properties using the ",(0,a.kt)("inlineCode",{parentName:"p"},"field")," element.\nAll fields must specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute, which by default, is used to get and set the field value from the bean\nobject."),(0,a.kt)("p",null,"Default getter and setter methods can be overridden using ",(0,a.kt)("inlineCode",{parentName:"p"},"getter")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setter")," attributes as shown below. If a field is\na constructor argument, ",(0,a.kt)("inlineCode",{parentName:"p"},"setter")," can be set to '#N' where N is the position of the argument in the constructor starting\nat 1 (not shown)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="stream1" format="csv">\n    <record name="record1" class="example.Record">\n      <field name="firstName" />\n      <field name="lastName" setter="setSurname" getter="getSurname"/>\n      <field name="age" />\n    </record>\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("p",null,"Fields found in a stream that do not map to a bean property can be declared using the ",(0,a.kt)("inlineCode",{parentName:"p"},"ignore")," field attribute. Note\nthat any configured validation rules are still applied to ignored fields (not shown)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="stream1" format="csv">\n    <record name="record1" class="example.Record">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="age" />\n      <field name="filler" ignore="true" />\n    </record>\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("p",null,"By default, BeanIO expects fields to appear in a CSV, delimited or fixed length stream in the same order they are\ndeclared in the mapping file. If this is not the case, a ",(0,a.kt)("inlineCode",{parentName:"p"},"position")," field attribute can be configured for each field. If\na position is declared for one field, a position must be declared for all other fields in the same record. For\ndelimited (and CSV) formatted streams, ",(0,a.kt)("inlineCode",{parentName:"p"},"position")," should be set to the index of the first occurrence of the field in the\nrecord, beginning at 0. For fixed length formatted streams, ",(0,a.kt)("inlineCode",{parentName:"p"},"position")," should be set to the index of the first character\nof the first occurrence of the field in the record, beginning at 0. A negative position can be used to specify a field\nlocation relative to the end of the record. For example, a position of -2 indicates the second to last field in a\ndelimited record."),(0,a.kt)("p",null,"The following example shows how the position attribute can be used. Although the fields are declared in a different\norder, the record definition is identical to the previous example. When positions are explicitly configured for an input\nstream, there is no need to declare all fields in a record, unless desired for validation purposes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="stream1" format="csv">\n    <record name="record1" class="example.Record">\n      <field name="filler" position="3" ignore="true" />\n      <field name="lastName" position="1" />\n      <field name="age" position="2"/>\n      <field name="firstName" position="0" />\n    </record>\n  </stream>\n  \n</beanio>\n')),(0,a.kt)("h4",{id:"431-field-type-conversion"},"4.3.1. Field Type Conversion"),(0,a.kt)("p",null,"The property type of a field is determined by introspecting the bean object the field belongs to. If the bean class is\nof type ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Map")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Collection"),", BeanIO will assume the field is of type ",(0,a.kt)("inlineCode",{parentName:"p"},"java.lang.String"),", unless a\nfield type is explicitly declared using a field's ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," attribute."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," attribute may be set to any fully qualified class name or to one of the supported type aliases below. Type\naliases are not case sensitive, and the same alias may be used for primitive types. For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"java.lang.Integer")," bean properties will use the same type handler registered for the type ",(0,a.kt)("inlineCode",{parentName:"p"},"java.lang.Integer"),", or\nalias ",(0,a.kt)("inlineCode",{parentName:"p"},"integer")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Class Name"),(0,a.kt)("th",null,"Primitive"),(0,a.kt)("th",null,"Alias(es)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.String"),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"string"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Boolean"),(0,a.kt)("td",null,"boolean"),(0,a.kt)("td",null,(0,a.kt)("code",null,"boolean"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Byte"),(0,a.kt)("td",null,"byte"),(0,a.kt)("td",null,(0,a.kt)("code",null,"byte"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Character"),(0,a.kt)("td",null,"char"),(0,a.kt)("td",null,(0,a.kt)("code",null,"character"),(0,a.kt)("br",null),(0,a.kt)("code",null,"char"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Short"),(0,a.kt)("td",null,"short"),(0,a.kt)("td",null,(0,a.kt)("code",null,"short"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Integer"),(0,a.kt)("td",null,"int"),(0,a.kt)("td",null,(0,a.kt)("code",null,"integer"),(0,a.kt)("br",null),(0,a.kt)("code",null,"int"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Long"),(0,a.kt)("td",null,"long"),(0,a.kt)("td",null,(0,a.kt)("code",null,"long"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Float"),(0,a.kt)("td",null,"float"),(0,a.kt)("td",null,(0,a.kt)("code",null,"float"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Double"),(0,a.kt)("td",null,"double"),(0,a.kt)("td",null,(0,a.kt)("code",null,"double"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.math.BigInteger"),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"biginteger"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.math.BigDecimal"),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"bigdecimal"),(0,a.kt)("br",null),(0,a.kt)("code",null,"decimal"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Date",(0,a.kt)("sup",null,"1")),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"datetime"),(0,a.kt)("br",null),(0,a.kt)("code",null,"date"),(0,a.kt)("br",null),(0,a.kt)("code",null,"time"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Calendar",(0,a.kt)("sup",null,"2")),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"calendar"),(0,a.kt)("br",null),(0,a.kt)("code",null,"calendar-datetime"),(0,a.kt)("br",null),(0,a.kt)("code",null,"calendar-date"),(0,a.kt)("br",null),(0,a.kt)("code",null,"calendar-time"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.UUID"),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"uuid"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.net.URL"),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"url"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.lang.Enum",(0,a.kt)("sup",null,"3")),(0,a.kt)("td",null,"-"),(0,a.kt)("td",null,(0,a.kt)("code",null,"-"))))),(0,a.kt)("p",null,"\xa0",(0,a.kt)("sup",null,"1")," By default, the ",(0,a.kt)("inlineCode",{parentName:"p"},"date")," alias is used for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Date")," types that contain date information only, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"time"),"\nalias is used for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Date")," types that contain only time information. Only the ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime")," alias can be used to\nreplace the default type handler for the ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Date")," class."),(0,a.kt)("p",null,"\xa0",(0,a.kt)("sup",null,"2")," By default, the ",(0,a.kt)("inlineCode",{parentName:"p"},"calendar-date")," alias is used for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Calendar")," types that contain date information only, and\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"calendar-time")," alias is used for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Date")," types that contain only time information. Only\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"calendar-datetime")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"calendar")," aliases can be used to replace the default type handler for\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Calendar")," class."),(0,a.kt)("p",null,"\xa0",(0,a.kt)("sup",null,"3")," By default, enums are converted using ",(0,a.kt)("inlineCode",{parentName:"p"},"Enum.valueOf(Class, String)"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},'format="toString"'),", the enum will be\nconverted using values computed by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"toString()")," for each enum value. In either case, conversion is case\nsensitive. As with other types, a custom type handler can also be used for enums."),(0,a.kt)("p",null,"Optionally, a ",(0,a.kt)("inlineCode",{parentName:"p"},"format")," attribute can be used to pass a decimal format for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.lang.Number")," types, and for passing a\ndate format for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Date")," types. In the example below, the ",(0,a.kt)("inlineCode",{parentName:"p"},"hireDate")," field uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"SimpleDateFormat"),' pattern "\nyyyy-MM-dd", and the ',(0,a.kt)("inlineCode",{parentName:"p"},"salary")," field uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"DecimalFormat"),' pattern "#,##0". For more information about supported\npatterns, please reference the API documentation for Java\'s ',(0,a.kt)("inlineCode",{parentName:"p"},"java.text.DecimalFormat")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"java.text.SimpleDateFormat"),"\nclasses."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="header" minOccurs="1" maxOccurs="1" class="map">\n      <field name="recordType" rid="true" literal="Header" />\n      <field name="fileDate" type="java.util.Date" />\n    </record>\n    <record name="employee" minOccurs="0" maxOccurs="unbounded" class="map">\n      <field name="recordType" rid="true" literal="Detail" />\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" type="int" format="#,##0" />\n      <field name="hireDate" type="date" format="yyyy-MM-dd" />\n    </record>\n    <record name="trailer" minOccurs="1" maxOccurs="1" class="map">\n      <field name="recordType" rid="true" literal="Trailer" />\n      <field name="recordCount" type="int" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h4",{id:"432-custom-type-handlers"},"4.3.2. Custom Type Handlers"),(0,a.kt)("p",null,"Field type conversion is performed by a ",(0,a.kt)("em",{parentName:"p"},"type handler"),". BeanIO includes type handlers for common Java types, or you can\ncreate your own type handler by implementing the ",(0,a.kt)("inlineCode",{parentName:"p"},"org.beanio.types.TypeHandler")," interface shown below. When writing a\ncustom type handler, make sure to handle null values and empty strings. Only one instance of your type handler is\ncreated, so if you plan to concurrently read or write multiple streams, make sure your type handler is also thread safe."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package org.beanio.types;\n\npublic interface TypeHandler {\n    public Object parse(String text) throws TypeConversionException;\n    public String format(Object value);\n    public Class<?> getType();\n}\n")),(0,a.kt)("p",null,"The following example shows a custom type handler for the ",(0,a.kt)("inlineCode",{parentName:"p"},"java.lang.Boolean")," class and ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),' primitive based on "Y"\nor "N" indicators.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'import org.beanio.types.TypeHandler;\n\npublic class YNTypeHandler implements TypeHandler {\n    public Object parse(String text) throws TypeConversionException {\n        return "Y".equals(text);\n    }\n    public String format(Object value) {\n        return value != null && ((Boolean)value).booleanValue() ? "Y" : "N";\n    }\n    public Class<?> getType() {\n        return Boolean.class;\n    }\n}\n')),(0,a.kt)("p",null,"A type handler may be explicitly named using the ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute, and/or registered for all fields of a particular type\nby setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," attribute. The ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," attribute can be set to the fully qualified class name or type alias of the\nclass supported by the type handler. To reference a named type handler, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"typeHandler")," field attribute when\nconfiguring the field."),(0,a.kt)("p",null,"Many default type handlers included with BeanIO support customization through the use of one or more ",(0,a.kt)("inlineCode",{parentName:"p"},"property"),"\nelements, where the ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute is a bean property of the type handler, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," attribute is the property\nvalue."),(0,a.kt)("p",null,"Type handlers can be declared globally (for all streams in the mapping file) or for a specific stream. Globally declared\ntype handlers may optionally use a ",(0,a.kt)("inlineCode",{parentName:"p"},"format")," attribute to narrow the type handler scope to a specific stream format."),(0,a.kt)("p",null,"In the example below, the first ",(0,a.kt)("inlineCode",{parentName:"p"},"DateTypeHandler")," is declared globally for all stream formats. The\nsecond ",(0,a.kt)("inlineCode",{parentName:"p"},"DateTypeHandler")," overrides the first for ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Date")," types in an XML formatted stream, and\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"YNTypeHandler")," is declared only for the 'employeeFile' stream. Stream specific type handlers override global type\nhandlers when declared with the same name or for the same type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <typeHandler type="java.util.Date" class="org.beanio.types.DateTypeHandler">\n    <property name="pattern" value="MMddyyyy" />\n    <property name="lenient" value="true" />\n  </typeHandler>\n  <typeHandler type="java.util.Date" format="xml" class="org.beanio.types.DateTypeHandler">\n    <property name="pattern" value="yyyy-MM-dd" />\n  </typeHandler>\n\n  <stream name="employeeFile" format="csv">\n    <typeHandler name="ynHandler" class="example.YNTypeHandler" />\n\n    <record name="employee" minOccurs="0" maxOccurs="unbounded" class="map">\n      <field name="recordType" rid="true" literal="Detail" />\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" />\n      <field name="exempt" typeHandler="ynHandler" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h4",{id:"433-repeating-fields"},"4.3.3. Repeating Fields"),(0,a.kt)("p",null,"Repeating fields are also supported by BeanIO. For example, lets assume our ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," bean object contains a list of\naccount numbers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n    List<Integer> accounts;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"And lets assume our input file now looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Joe,Smith,Developer,75000,10012009\nChris,Johnson,Sales,80000,05292006,100012,200034,200045\nJane,Doe,Architect,80000,01152008\nJon,Anderson,Manager,85000,03182007,333001\n")),(0,a.kt)("p",null,"In this example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"accounts")," bean property can be defined in the mapping file using a ",(0,a.kt)("inlineCode",{parentName:"p"},"collection")," field attribute.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"collection")," attribute can be set to the fully qualified class name of a ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Collection")," subclass, or to one\nof the collection type aliases below."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Class"),(0,a.kt)("th",null,"Alias"),(0,a.kt)("th",null,"Default Implementation")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Collection"),(0,a.kt)("td",null,(0,a.kt)("code",null,"collection")),(0,a.kt)("td",null,"java.util.ArrayList")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.List"),(0,a.kt)("td",null,(0,a.kt)("code",null,"list")),(0,a.kt)("td",null,"java.util.ArrayList")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Set"),(0,a.kt)("td",null,(0,a.kt)("code",null,"set")),(0,a.kt)("td",null,"java.util.HashSet")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"(Java Array)"),(0,a.kt)("td",null,(0,a.kt)("code",null,"array")),(0,a.kt)("td",null,"N/A")))),(0,a.kt)("p",null,"Repeating fields can declare the number of occurrences of the field using the ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," field\nattributes. If not declared, ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," will default to 1, and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," will default to the ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," value or 1,\nwhichever is greater."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n      <field name="accounts" type="int" collection="list" minOccurs="0" maxOccurs="unbounded" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"Flat file formats (CSV, delimited and fixed length) may only contain one field or segment of indeterminate length (i.e.\nwhere ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," is greater than ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs"),"). The position of components that follow are assumed to be relative to the\nend of the record."),(0,a.kt)("p",null,"If a field repeats a fixed number of times based on a preceding field in the same record, the ",(0,a.kt)("inlineCode",{parentName:"p"},"occursRef")," attribute can\nbe used to identify the name of the controlling field. If the controlling field is not bound to a separate property of\nits parent bean object, be sure to specify ",(0,a.kt)("inlineCode",{parentName:"p"},'ignore="true"'),". The following mapping file shows how to configure the ",(0,a.kt)("em",{parentName:"p"},"\naccounts")," field occurrences to be dependent on the ",(0,a.kt)("em",{parentName:"p"},"numberOfAccounts")," field. If desired, ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," may\nstill be specified to validate the referenced field occurrences value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n      <field name="numberOfAccounts" ignore="true" />\n      <field name="accounts" type="int" collection="list" occursRef="numberOfAccounts" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"Note that a repeating field can not be used for record identification."),(0,a.kt)("h4",{id:"434-fixed-length-fields"},"4.3.4. Fixed Length Fields"),(0,a.kt)("p",null,"Fixed length fields require a little extra configuration than their delimited counterparts. Let's redefine our employee\nfile example using the fixed length format below."),(0,a.kt)("div",{className:"indent"},(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Position"),(0,a.kt)("th",null,"Field"),(0,a.kt)("th",null,"Format"),(0,a.kt)("th",null,"Length")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"First Name"),(0,a.kt)("td",null,"Text"),(0,a.kt)("td",null,"10")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"10"),(0,a.kt)("td",null,"Last Name"),(0,a.kt)("td",null,"Text"),(0,a.kt)("td",null,"10")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"20"),(0,a.kt)("td",null,"Job Title"),(0,a.kt)("td",null,"Text"),(0,a.kt)("td",null,"10")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"30"),(0,a.kt)("td",null,"Salary"),(0,a.kt)("td",null,"Number"),(0,a.kt)("td",null,"6")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"36"),(0,a.kt)("td",null,"Hire Date"),(0,a.kt)("td",null,"Date (MMDDYYYY)"),(0,a.kt)("td",null,"8"))))),(0,a.kt)("p",null,"A fixed length version of the employee file might look like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Joe       Smith    Developer 07500010012009\nJane      Doe      Architect 08000001152008\nJon       Anderson Manager   08500003182007\n")),(0,a.kt)("p",null,"The length of a fixed length field must be configured using the ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," field attribute. By default, fixed length\nfields are left justified and padded with spaces, but these settings can be overridden using the ",(0,a.kt)("inlineCode",{parentName:"p"},"padding")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"justify"),"\nfield attributes. Field padding can be set to any single character, and field justification can be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"left"),"\nor ",(0,a.kt)("inlineCode",{parentName:"p"},"right"),". Using these attributes, our mapping file can now be updated as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" length="10" />\n      <field name="lastName" length="10" />\n      <field name="title" length="10" />\n      <field name="salary" length="6" padding="0" justify="right" />\n      <field name="hireDate" length="8" format="MMddyyyy" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"The configured padding character is removed from the beginning of the field if right justified, or from the end of the\nfield if left justified, until a character is found that does not match the padding character. If the entire field is\npadded, ",(0,a.kt)("inlineCode",{parentName:"p"},"Number")," property types default to the padding character if it is a digit, and the padding character is ignored\nfor ",(0,a.kt)("inlineCode",{parentName:"p"},"Character")," types. To illustrate this, some examples are shown in the table below."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Justify"),(0,a.kt)("th",null,"Type"),(0,a.kt)("th",null,"Padding"),(0,a.kt)("th",null,"Padded Text"),(0,a.kt)("th",null,"Unpadded Text")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"4"},(0,a.kt)("code",null,"left")),(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,"String")),(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,'"\xa0"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"George\xa0\xa0"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"George"'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,'"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'""'))),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,"Character")),(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,'"\xa0"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"A"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"A"'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,'" "')),(0,a.kt)("td",null,(0,a.kt)("code",null,'" "'))),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("code",null,"right")),(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("code",null,"Number")),(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,'"0"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"00123"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"123"'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,'"00000"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"0"'))),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,'"9"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"00000"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"00000"'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,'"99999"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"9"'))),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"1"},(0,a.kt)("code",null,'"X"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'"XXXXX"')),(0,a.kt)("td",null,(0,a.kt)("code",null,'""'))))),(0,a.kt)("p",null,"The marshalling and unmarshalling behavior of null field values for a padded field is further controlled using\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"required")," attribute. If ",(0,a.kt)("inlineCode",{parentName:"p"},"required")," is set to true, null field values are marshalled by filling the field with the\npadding character. If ",(0,a.kt)("inlineCode",{parentName:"p"},"required")," is set to false, a null field value is marshalled as spaces for fixed length streams\nand an empty string for non-fixed length streams. Similarly, if ",(0,a.kt)("inlineCode",{parentName:"p"},"required")," is set to false, spaces are unmarshalled to a\nnull field value regardless of the padding character. To illustrate this, the following table shows the field text for a\nright justified zero padded 3 digit number."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Field Value"),(0,a.kt)("th",null,"Field Text",(0,a.kt)("br",null)," (Fixed Length)"),(0,a.kt)("th",null,"Field Text",(0,a.kt)("br",null),"(CSV, Delimited, XML)")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,"true")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"000"),'"'),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"000"),'"')),(0,a.kt)("tr",null,(0,a.kt)("td",null,"null"),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"000"),'"',(0,a.kt)("sup",null,"1")),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"000"),'"',(0,a.kt)("sup",null,"1"))),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,"false")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"000"),'"'),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"000"),'"')),(0,a.kt)("tr",null,(0,a.kt)("td",null,"null"),(0,a.kt)("td",null,'"',(0,a.kt)("code",null,"\xa0\xa0\xa0"),'"'),(0,a.kt)("td",null,'""')))),(0,a.kt)("sup",null,"1"),' Applies to marshalling only. Unmarshalling "000" would produce a field value of 0.',(0,a.kt)("p",null,"As hinted to above, padding settings can be applied to any field for any stream type."),(0,a.kt)("h3",{id:"44-constants"},"4.4. Constants"),(0,a.kt)("p",null,"If a bean property does not map to a field in the stream, a constant property value can still be set using a ",(0,a.kt)("inlineCode",{parentName:"p"},"property"),"\nelement. Like a field, all properties must specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute, which by default, is used to get and set the\nproperty value from the bean object. Properties also require a ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," attribute for setting the textual representation\nof the property value. The value text is type converted using the same rules and attributes (",(0,a.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"typeHandler"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"format"),") used for field type conversion described above. Collection type properties are not supported."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="map">\n      <property name="recordType" value="employee" />\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"Constant properties may be useful in two scenarios:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When reading an input stream (unmarshalling), if multiple records are mapped to the same bean class, such as a Map, a\nproperty can be used to set a property, or a Map key, for identifying the record type without querying\nthe ",(0,a.kt)("inlineCode",{parentName:"li"},"BeanReader"),"."),(0,a.kt)("li",{parentName:"ul"},"When writing an output stream (marshalling), a record mapping can be selected based on a record identifying property\nvalue by setting ",(0,a.kt)("inlineCode",{parentName:"li"},"rid")," to true. This allows the same bean class to be unmarshalled to different record types based on\na property that may not exist in the output stream.")),(0,a.kt)("h3",{id:"45-segments"},"4.5. Segments"),(0,a.kt)("p",null,"A segment is a group of fields within a record. Segments are most often used to bind a group of fields to a nested bean\nobject or collection of bean objects, and are configured in a mapping file using a ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," element."),(0,a.kt)("p",null,"Prior to release 2.x, the ",(0,a.kt)("inlineCode",{parentName:"p"},"bean")," element performed this task. A ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," supports all the functionality of a ",(0,a.kt)("inlineCode",{parentName:"p"},"bean"),"\nelement, but unlike the original ",(0,a.kt)("inlineCode",{parentName:"p"},"bean")," element, a ",(0,a.kt)("inlineCode",{parentName:"p"},"segment"),' is not required to be bound to a bean object. This allows\nrepeating segments to be fully validated during unmarshalling, without necessarily binding the fields to a bean object.\nAn "unbound" segment also allows an arbitrary number of XML fields to be wrapped by other XML nodes without creating\nbean objects that mirror the same hierarchy.'),(0,a.kt)("h4",{id:"451-nested-beans"},"4.5.1. Nested Beans"),(0,a.kt)("p",null,"As mentioned, a record can be divided into nested bean objects using a ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," element. First, let's suppose we store\nan address in our CSV employee file, so that the record layout might look like this:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Position"),(0,a.kt)("th",null,"Field"),(0,a.kt)("th",null,"Format")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"First Name"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Last Name"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Job Title"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Salary"),(0,a.kt)("td",null,"Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Hire Date"),(0,a.kt)("td",null,"Date (MMDDYYYY)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"5"),(0,a.kt)("td",null,"Street"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"6"),(0,a.kt)("td",null,"City"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"7"),(0,a.kt)("td",null,"State"),(0,a.kt)("td",null,"Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"8"),(0,a.kt)("td",null,"Zip"),(0,a.kt)("td",null,"Text")))),(0,a.kt)("p",null,"Second, lets suppose we want to store address information in a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Address")," bean object like the one below, and add\nan ",(0,a.kt)("inlineCode",{parentName:"p"},"Address")," reference to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," class."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\n\npublic class Address {\n    String street;\n    String city;\n    String state;\n    String zip;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n    Address mailingAddress;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"With this information, we can now update our employee CSV mapping file to accomodate the nested ",(0,a.kt)("inlineCode",{parentName:"p"},"Address")," object.\nA ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," must include a ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute, and may optionally provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," attribute to bind its children to a\nbean object. If ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," is set, the attribute must be set to the fully qualified class name of the bean object, or\nto ",(0,a.kt)("inlineCode",{parentName:"p"},"map"),", or to the class name of any concrete ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Map")," implementation. If the bean class is of\ntype ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Map"),", field values are stored in the Map using the configured field names for keys. By default,\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute is used to determine the getter and setter on its parent bean or record. Alternatively, ",(0,a.kt)("inlineCode",{parentName:"p"},"getter"),"\nor ",(0,a.kt)("inlineCode",{parentName:"p"},"setter")," attributes can be used to override the default property name similar to a field property."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n      <segment name="mailingAddress" class="example.Address">\n        <field name="street" />\n        <field name="city" />\n        <field name="state" />\n        <field name="zip" />\n      </segment>\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," is not set, fields will be automatically bound to the segment's parent bean object, which would be\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," object in the example above."),(0,a.kt)("p",null,"If needed, segments can be further divided into other segments. There is no limit to the number of nested levels that\ncan be configured in a mapping file."),(0,a.kt)("h4",{id:"452-repeating-segments"},"4.5.2. Repeating Segments"),(0,a.kt)("p",null,"Similar to repeating fields, BeanIO supports repeating segments, which may be bound to a collection of bean objects.\nContinuing our previous example, let's suppose the employee CSV file may contain 1 or more addresses for each employee.\nThus our ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," bean object might look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n    List<Address> addressList;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"And our input file might look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Joe,Smith,Developer,75000,10012009,123 State St,Chicago,IL,60614\nJane,Doe,Architect,80000,01152008,456 Main St,Chicago,IL,60611,111 Michigan Ave,Chicago,IL,60611\nJon,Anderson,Manager,85000,03182007,1212 North Ave,Chicago,IL,60614\n")),(0,a.kt)("p",null,"In our mapping file, in order to bind a segment to a collection, simply set it's ",(0,a.kt)("inlineCode",{parentName:"p"},"collection")," attribute to the fully\nqualified class name of a ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Collection")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Map")," subclass, or to one of the collection type aliases\nbelow."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Class"),(0,a.kt)("th",null,"Alias"),(0,a.kt)("th",null,"Default Implementation")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Collection"),(0,a.kt)("td",null,(0,a.kt)("code",null,"collection")),(0,a.kt)("td",null,"java.util.ArrayList")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.List"),(0,a.kt)("td",null,(0,a.kt)("code",null,"list")),(0,a.kt)("td",null,"java.util.ArrayList")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Set"),(0,a.kt)("td",null,(0,a.kt)("code",null,"set")),(0,a.kt)("td",null,"java.util.HashSet")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"java.util.Map"),(0,a.kt)("td",null,(0,a.kt)("code",null,"map")),(0,a.kt)("td",null,"java.util.LinkedHashMap")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"(Java Array)"),(0,a.kt)("td",null,(0,a.kt)("code",null,"array")),(0,a.kt)("td",null,"N/A")))),(0,a.kt)("p",null,"Repeating segments can declare the number of occurrences using the ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," attributes. If not\ndeclared, ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," will default to 1, and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," will default to the ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," value or 1, whichever is\ngreater."),(0,a.kt)("p",null,"Just like repeating fields, if the number of occurrences of a segment is dependent on a preceding field in the same\nrecord, the ",(0,a.kt)("inlineCode",{parentName:"p"},"occursRef")," attribute can be set to the name of the field that controls the number of occurrences."),(0,a.kt)("p",null,"Flat file formats (CSV, delimited and fixed length) may only contain one field or segment of indeterminate length (i.e.\nwhere ",(0,a.kt)("inlineCode",{parentName:"p"},"maxOccurs")," is greater than ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs"),"). The position of components that follow are assumed to be relative to the\nend of the record."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" format="MMddyyyy" />\n      <segment name="addressList" collection="list" minOccurs="1" maxOccurs="unbounded" class="example.Address">\n        <field name="street" />\n        <field name="city" />\n        <field name="state" />\n        <field name="zip" />\n      </segment>\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"When working with repeating segments, there are a few restrictions to keep in mind:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Repeating segments must appear consecutively in the record."),(0,a.kt)("li",{parentName:"ul"},"Every field in a repeating segment must be declared. (There can be no field gaps in the segment configuration.)"),(0,a.kt)("li",{parentName:"ul"},"A repeating segment may not contain repeating descendants with variable occurrences."),(0,a.kt)("li",{parentName:"ul"},"Repeating fields or fields that belong to a repeating segment may not be used for record identification.")),(0,a.kt)("h4",{id:"4521-inline-maps"},"4.5.2.1. Inline Maps"),(0,a.kt)("p",null,"As noted above, a segment can also be bound to a ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Map"),' which provides support for "inline" maps. For example,\ngiven the following CSV file of users,'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"id1,firstName1,lastName1,id2,firstName2,lastName2\njsmith,Joe,Smith,jdoe,Jane,Doe\n")),(0,a.kt)("p",null,"The following mapping file could be used to create a Map of ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," objects by ID. The ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," attribute is used to set the\nname of a descendant field to use for the Map key."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" target="userMap">\n      <segment name="userMap" class="example.User" collection="map" key="id"\n          minOccurs="1" maxOccurs="unbounded">\n        <field name="id" />\n        <field name="firstName" />\n        <field name="lastName" />\n      </segment>\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"If a Map of last names by ID is needed instead, simply replace the ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," attribute with ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," and specify the name\nof the descendant field to use for the Map value. In this case, first name is effectively ignored."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" target="userMap">\n      <segment name="userMap" collection="map" key="id" value="lastName"\n          minOccurs="1" maxOccurs="unbounded">\n        <field name="id" />\n        <field name="firstName" />\n        <field name="lastName" />\n      </segment>\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h3",{id:"46-stream-validation"},"4.6. Stream Validation"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," will throw an ",(0,a.kt)("inlineCode",{parentName:"p"},"InvalidRecordException")," if a record or one of its fields fails a configured validation\nrule. There are two types of errors reported for an invalid record: record level errors and field level errors. If a\nrecord level error occurs, further processing of the record is aborted and an excception is immediately thrown. If a\nfield level error is reported, the ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," will continue to process the record's other fields before throwing an\nexception."),(0,a.kt)("p",null,"When an ",(0,a.kt)("inlineCode",{parentName:"p"},"InvalidRecordException")," is thrown, the exception will contain the reported record and field level errors. The\nfollowing code shows how this information can be accessed using the ",(0,a.kt)("inlineCode",{parentName:"p"},"RecordContext"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"    try (BeanReader in = ...) {\n        Object record = in.read();\n        if (record != null) {\n            // process record...\n        }\n    }\n    catch (InvalidRecordException ex) {\n        RecordContext context = ex.getRecordContext();\n        if (context.hasRecordErrors()) {\n            for (String error : context.getRecordErrors()) {\n                // handle record errors...\n            }\n        }\n        if (context.hasFieldErrors()) {\n            for (String field : context.getFieldErrors().keySet()) {\n                for (String error : context.getFieldErrors(field)) {\n                    // handle field error...\n                }\n            }\n        }\n    }\n}\n")),(0,a.kt)("p",null,"Alternatively, it may be simpler to register a ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderErrorHandler")," for handling non-fatal exceptions. The example\nbelow shows how invalid records could be written to a reject file by extending ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReaderErrorHandlerSupport"),". (Note\nthat the example assumes the mapping file does not bind a record group to a bean object.)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"    try (BeanReader input = ...;\n         BufferedWriter rejects = ...) {\n        input.setErrorHandler(new BeanReaderErrorHandlerSupport() {\n            public void invalidRecord(InvalidRecordException ex) throws Exception {\n                rejects.write(ex.getRecordContext().getRecordText());\n                rejects.newLine();\n            }\n        });\n\n        Object record = null;\n        while ((record = input.read()) != null) {\n            // process a valid record\n        }\n\n        rejects.flush();\n    }\n")),(0,a.kt)("p",null,"Record and field level error messages can be customized and localized through the use of resource bundles. A resource\nbundle is configured at the stream level using the ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceBundle")," attribute as shown below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <typeHandler type="java.util.Date" class="org.beanio.types.DateTypeHandler">\n    <property name="pattern" value="MMddyyyy" />\n  </typeHandler>\n\n  <stream name="employeeFile" format="csv" resourceBundle="example.messages" >\n    <record name="employee" class="map">\n      <field name="recordType" rid="true" literal="Detail" />\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"Record level error messages are retrieved using the following prioritized list of keys. If a message is not configured\nunder the name of the first key, the next key will be tried until a message is found, or a default message is used."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"recorderror.[record name].[rule]")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"recorderror.[rule]"))),(0,a.kt)("p",null,"Similarly, field level error messages are retrieved using the following priortized list of keys:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"fielderror.[record name].[field name].[rule]")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"fielderror.[record name].[rule]")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"fielderror.[rule]"))),(0,a.kt)("p",null,"More descriptive or localized labels can be configured for record and field names using the keys ",(0,a.kt)("inlineCode",{parentName:"p"},"label.[record name]"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"label.[record name].[field name]")," respectively."),(0,a.kt)("p",null,"For example, the following resource bundle could be used to customize a few error messages for the employee file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-properties"},"## 'employee' record label:\nlabel.employee = Employee Record\n## 'firstName' field label:\nlabel.employee.firstName = First Name Field\n## Unidentified record error message:\nrecorderror.unidentified = Unidentified record at line {0}\n## Type conversion error message for the 'hireDate' field:\nfielderror.employee.hireDate.type = Invalid date format\n## Maximum field length error message for all fields:\nfielderror.maxLength = Maximum field length exceeded for {3}\n")),(0,a.kt)("p",null,"Error messages are formatted using a ",(0,a.kt)("inlineCode",{parentName:"p"},"java.text.MessageFormat"),". Depending on the validation rule that was violated,\ndifferent parameters are passed to the ",(0,a.kt)("inlineCode",{parentName:"p"},"MessageFormat"),". ",(0,a.kt)("a",{parentName:"p",href:"#B"},"Appendix B")," documents the parameters passed to\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"MessageFormat")," for each validation rule."),(0,a.kt)("h4",{id:"461-record-validation"},"4.6.1. Record Validation"),(0,a.kt)("p",null,"The following record level validation rules may be configured on a ",(0,a.kt)("inlineCode",{parentName:"p"},"record")," element."),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Argument Type"),(0,a.kt)("th",null,"Description")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minLength")),(0,a.kt)("td",null,"Integer"),(0,a.kt)("td",null,"Validates the record contains at least ",(0,a.kt)("code",null,"minLength")," fields for delimited and CSV formatted streams, or has at least ",(0,a.kt)("code",null,"minLength")," characters for fixed length formatted streams.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxLength")),(0,a.kt)("td",null,"Integer"),(0,a.kt)("td",null,"Validates the record contains at most ",(0,a.kt)("code",null,"maxLength")," fields for delimited and CSV formatted streams, or has at most ",(0,a.kt)("code",null,"maxLength")," characters for fixed length formatted streams.")))),(0,a.kt)("h4",{id:"462-field-validation"},"4.6.2. Field Validation"),(0,a.kt)("p",null,"BeanIO supports several common field validation rules when reading an input stream. All field validation rules are\nvalidated against the field text before type conversion. When field trimming is enabled, ",(0,a.kt)("inlineCode",{parentName:"p"},'trim="true"'),", all validations\nare performed after the field's text has first been trimmed. Field validations are ignored when writing to an output\nstream."),(0,a.kt)("p",null,"The following table lists supported field attributes for validation."),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Argument Type"),(0,a.kt)("th",null,"Description")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"required")),(0,a.kt)("td",null,"Boolean"),(0,a.kt)("td",null,"When set to ",(0,a.kt)("code",null,"true"),", validates the field is present and the field text is not the empty string.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minLength")),(0,a.kt)("td",null,"Integer"),(0,a.kt)("td",null,"Validates the field text is at least N characters.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxLength")),(0,a.kt)("td",null,"Integer"),(0,a.kt)("td",null,"Validates the field text does not exceed N characters.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"literal")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"Validates the field text exactly matches the literal value.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"regex")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"Validates the field text matches the given regular expression pattern.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"String"),(0,a.kt)("td",null,"Validates the minimum occurrences of the field in a stream.  If the field is present in the stream,",(0,a.kt)("code",null,"minOccurs")," is satisfied, and the ",(0,a.kt)("code",null,"required")," setting determines whether a value is required.")))),(0,a.kt)("h3",{id:"47-templates"},"4.7. Templates"),(0,a.kt)("p",null,"When a common set of fields is used by multiple record types, configuration may be simplified using templates. A\ntemplate is a reusable list of components (segments, fields, and properties/constants) that can be included by a record,\nsegment or other template. The following example illustrates some of the ways a template can be used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <template name="address">\n    <field name="street1" />\n    <field name="street2" />\n    <field name="city" />\n    <field name="state" />\n    <field name="zip" />\n  </template>\n\n  <template name="employee">\n    <field name="firstName" />\n    <field name="lastName" />\n    <field name="title" />\n    <field name="salary" />\n    <field name="hireDate" format="MMddyyyy" />\n    <segment name="mailingAddress" template="address" class="example.Address" />\n  </template>\n\n  <stream name="employeeFile" format="csv">\n    <record name="employee" template="employee" class="example.Employee" />\n  </stream>\n\n  <stream name="addressFile" format="csv">\n    <record name="address" class="example.Address">\n      <field name="location" />\n      <include template="address"/>\n      <field name="attention" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"Templates are essentially copied into their destination using the ",(0,a.kt)("inlineCode",{parentName:"p"},"include")," element. For convenience, ",(0,a.kt)("inlineCode",{parentName:"p"},"record"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," elements support a ",(0,a.kt)("inlineCode",{parentName:"p"},"template")," attribute which includes the template before any other children."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"include")," element can optionally specify a positional offset for included fields using the ",(0,a.kt)("inlineCode",{parentName:"p"},"offset")," attribute. The\nfollowing example illustrates this behavior. Even when using templates, remember that ",(0,a.kt)("inlineCode",{parentName:"p"},"position")," must be declared for\nall fields or none."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <template name="address">\n    <field name="street1" position="0" />\n    <field name="street2" position="1" />\n    <field name="city" position="2" />\n    <field name="state" position="3" />\n    <field name="zip" position="4" />\n  </template>\n\n  <stream name="addressFile" format="csv">\n    <record name="address" class="example.Address">\n      <field name="location" position="0" />\n      <include template="address" offset="1"/>\n      <field name="attention" position="6" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h3",{id:"48-advanced-topics"},"4.8. Advanced Topics"),(0,a.kt)("h4",{id:"481-mapping-bean-objects-that-span-multiple-records"},"4.8.1. Mapping Bean Objects that Span Multiple Records"),(0,a.kt)("p",null,"Since release 2.0, BeanIO supports the binding of multiple consecutive records to a single bean object. This can be\nachieved by assigning a bean class to a ",(0,a.kt)("inlineCode",{parentName:"p"},"stream")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"group")," containing the ",(0,a.kt)("inlineCode",{parentName:"p"},"record")," configurations bound to the bean."),(0,a.kt)("p",null,"Let's suppose we are reading a CSV input file of orders that contains an order, followed by the customer that placed the\norder, followed by a detailed list of items that make up the order. A sample input file might look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Order,101,2012-02-01,5.00\nCustomer,John,Smith\nItem,Apple,2,2.00\nItem,Orange,1,1.00\nOrder,102,2012-02-01,3.00\nCustomer,Jane,Johnson\nItem,Ham,1,3.00\n")),(0,a.kt)("p",null,"Let's then suppose we want to read the following ",(0,a.kt)("inlineCode",{parentName:"p"},"Order")," class from the stream, which contains a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"Customer"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"Item")," classes. (For brevity, getters and setters are not shown.)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Order {\n    String id;\n    Date date;\n    BigDecimal amount;\n    Customer customer;\n    List&lt;Item&gt; items;\n}\n\npublic class Customer {\n    String firstName;\n    String lastName;\n}\n\npublic class Item {\n    String name;\n    int quantity;\n    BigDecimal amount;\n}\n")),(0,a.kt)("p",null,"Now to read and write ",(0,a.kt)("inlineCode",{parentName:"p"},"Order")," objects from our example stream, the following mapping file can be used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="orders" format="csv">\n    <group name="order" class="example.Order" minOccurs="0" maxOccurs="unbounded">\n      <record name="orderRecord" order="1" minOccurs="1">\n        <field name="recordType" rid="true" literal="Order" ignore="true" />\n        <field name="id" />\n        <field name="date" format="yyyy-MM-dd" />\n        <field name="amount" />\n      </record>\n      <record name="customer" class="example.Customer" order="2" minOccurs="1" maxOccurs="1">\n        <field name="recordType" rid="true" literal="Customer" ignore="true" />\n        <field name="firstName" />\n        <field name="lastName" />\n      </record>\n      <record name="items" class="example.Item" collection="list" order="3" minOccurs="1" maxOccurs="unbounded">\n        <field name="recordType" rid="true" literal="Item" ignore="true" />\n        <field name="name" />\n        <field name="quantity" />\n        <field name="amount" />\n      </record>\n    </group>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"By configuring a ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," on a ",(0,a.kt)("inlineCode",{parentName:"p"},"group")," component, BeanIO will automatically marshal or unmarshal all of the group's\ndescendants in a single call to read or write from the stream. Also note that by not configuring a ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," on a ",(0,a.kt)("inlineCode",{parentName:"p"},"record"),'\n, in this case our "orderRecord", the fields are instead set on the bean class assigned to it\'s parent group. Finally,\nrepeating records can be aggregated into a collection using a ',(0,a.kt)("inlineCode",{parentName:"p"},"collection")," attribute at the ",(0,a.kt)("inlineCode",{parentName:"p"},"record"),' level, as used for\nthe "items" record. If necessary, ',(0,a.kt)("inlineCode",{parentName:"p"},"getter")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setter")," attributes can be configured on a ",(0,a.kt)("inlineCode",{parentName:"p"},"record")," component as well."),(0,a.kt)("p",null,"If any record included in a group bound to a bean object is invalid, an ",(0,a.kt)("inlineCode",{parentName:"p"},"InvalidRecordException")," is thrown, but only\nafter reading all the other records in the group. In such cases, the ",(0,a.kt)("inlineCode",{parentName:"p"},"InvalidRecordException")," will\ncontain ",(0,a.kt)("inlineCode",{parentName:"p"},"RecordContext")," objects for every record in the group read from the stream. If multiple records in the group are\ninvalid, only one ",(0,a.kt)("inlineCode",{parentName:"p"},"InvalidRecordException")," is thrown."),(0,a.kt)("p",null,"If a malformed or unidentified record is read from the stream while unmarsahalling a record group, an exception is\nimmediately thrown, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," will most likely ",(0,a.kt)("strong",{parentName:"p"},"not")," be able to recover. For this reason, when\nunmarshalling untrusted sources, it is recommended that you read the stream twice, using the first pass to validate the\nintegrity of the file including syntax, record identification, record ordering, possible header/trailer counts, etc. For\nexample, the following mapping file might be used to validate our orders file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="orders-validation" format="csv">\n    <group name="order" minOccurs="0" maxOccurs="unbounded">\n      <record name="orderRecord" order="1" minOccurs="1">\n        <field name="recordType" rid="true" literal="Order" ignore="true" />\n      </record>\n      <record name="customer" order="2" minOccurs="1">\n        <field name="recordType" rid="true" literal="Customer" ignore="true" />\n      </record>\n      <record name="items" order="3" minOccurs="1" maxOccurs="unbounded">\n        <field name="recordType" rid="true" literal="Item" ignore="true" />\n      </record>\n    </group>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"In this case, we are validating syntax, record ordering and record identification for the entire file in a single call\nto ",(0,a.kt)("inlineCode",{parentName:"p"},"beanReader.read()"),", while leaving other record and field level validations for unmarshalling, which can be caught\nand handled without worrying whether the ",(0,a.kt)("inlineCode",{parentName:"p"},"BeanReader")," will be able to recover."),(0,a.kt)("h2",{id:"50-mapping-xml-streams"},"5.0. Mapping XML Streams"),(0,a.kt)("p",null,"This section provides further details for using BeanIO to marshall and unmarshall Java objects to and from XML formatted\nstreams. This section assumes you are already familiar with the mapping file concepts documented in previous sections."),(0,a.kt)("h3",{id:"51-introduction"},"5.1. Introduction"),(0,a.kt)("p",null,"BeanIO is similar to other OXM (Object to XML Mapping) libraries, except that it is also capable of marshalling and\nunmarshalling extremely large XML files by reading and writing Java beans one record at a time. BeanIO uses a streaming\nXML (StAX) parser to read and write XML, and will never hold more than the minimum amount of XML in memory needed to\nmarshall or unmarshall a single bean object. That said, it is still possible to run out of memory (heap space) with\npoorly designed XML documents and/or misconfigured mapping files."),(0,a.kt)("h4",{id:"511-my-first-xml-stream"},"5.1.1. My First XML Stream"),(0,a.kt)("p",null,"Before diving into the details, let's start with a basic example using the employee input file\nfrom ",(0,a.kt)("a",{parentName:"p",href:"#MyFirstStream"},"Section 2.1")," after it's been converted to XML (shown below)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<employeeFile>\n  <employee>\n    <firstName>Joe</firstName>\n    <lastName>Smith</lastName>\n    <title>Developer</title>\n    <salary>75000</salary>\n    <hireDate>2009-10-12</hireDate>\n  </employee>\n  <employee>\n    <firstName>Jane</firstName>\n    <lastName>Doe</lastName>\n    <title>Architect</title>\n    <salary>80000</salary>\n    <hireDate>2008-01-15</hireDate>\n  </employee>\n  <employee>\n    <firstName>Jon</firstName>\n    <lastName>Andersen</lastName>\n    <title>Manager</title>\n    <salary>85000</salary>\n    <hireDate>2007-03-18</hireDate>\n  </employee>\n</employeeFile>\n')),(0,a.kt)("p",null,"In this example, let's suppose we are unmarshalling the XML employee file into the same ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," bean object from\nSection 2.1 and repeated below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"Our original mapping file from Section 2.1 can now be updated to parse XML instead of CSV with only two minor changes.\nFirst, the stream format is changed to ",(0,a.kt)("inlineCode",{parentName:"p"},"xml"),". And second, the hire date field format is removed and replaced\nwith ",(0,a.kt)("inlineCode",{parentName:"p"},'type="date"'),". With XML, the date format does not need to be explicity declared because it conforms to the W3C XML\nSchema date syntax. (This will be further explained in ",(0,a.kt)("a",{parentName:"p",href:"#XmlTypeConversion"},"Section 5.7.1"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio xmlns="http://www.beanio.org/2012/03"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd">\n\n  <stream name="employeeFile" format="xml">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n    </record>\n  </stream>\n</beanio>\n')),(0,a.kt)("p",null,"That's it! No Java code changes are required, and as before, ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," bean objects will be unmarshalled from the XML\ninput stream each time ",(0,a.kt)("inlineCode",{parentName:"p"},"beanReader.read()")," is called."),(0,a.kt)("p",null,"And also as before, ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," objects can be marshalled to an XML output stream using ",(0,a.kt)("inlineCode",{parentName:"p"},"beanWriter.write(Object)"),".\nHowever, please note that when marshalling/writing XML, it is even more important to call ",(0,a.kt)("inlineCode",{parentName:"p"},"beanWriter.close()")," so that\nthe XML document can be properly completed."),(0,a.kt)("h4",{id:"512-a-note-on-xml-validation"},"5.1.2. A Note on XML Validation"),(0,a.kt)("p",null,"Because BeanIO is built like a pull parser, it does not support XML validation against a DTD or XML schema. Where this\nfunctionality is needed, it is recommended to make two passes on the input document. The first pass can use a SAX parser\nor other means to validate the XML, and the second pass can use BeanIO to parse and process bean objects read from the\ndocument."),(0,a.kt)("h3",{id:"52-xml-names"},"5.2. XML Names"),(0,a.kt)("p",null,"Each BeanIO mapping component (stream, group, record, segment and field), is mapped to an XML element with the same\nlocal name. If the name of the stream, group, etc. does not match the XML element name, the ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlName"),' attribute can be\nused. For example, if the name of the root element in the previous example\'s employee file is changed from "\nemployeeFile" to "employees", and "title" was renamed "position", the mapping file could be updated as shown below.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="xml" xmlName="employees">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" xmlName="position" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h3",{id:"53-xml-namespaces"},"5.3. XML Namespaces"),(0,a.kt)("p",null,"XML namespaces can be enabled through the use of the ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlNamespace")," attribute on any mapping component (stream, group,\nrecord, segment or field). By default, all mapping elements inherit their namespace (or lack thereof) from their parent.\nWhen a namespace is declared, the local name ",(0,a.kt)("em",{parentName:"p"},"and")," namespace must match when unmarshalling XML, and appropriate\nnamespace declarations are included when marshalling bean objects. For example, let's suppose our employee file contains\nnamespaces as shown below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<employeeFile xmlns="http://example.com/employeeFile" xmlns:n="http://example.com/name">\n  <e:employee xmlns:e="http://example.com/employee">\n    <n:firstName>Joe</n:firstName>\n    <n:lastName>Smith</n:lastName>\n    <e:title>Developer</e:title>\n    <e:salary>75000</e:salary>\n    <e:hireDate>2009-10-12</e:hireDate>\n  </e:employee>\n  .\n  .\n  .\n</employeeFile>\n')),(0,a.kt)("p",null,"To unmarshall the file using namespaces, and to marshall Employee bean objects in the same fashion as they appear above,\nthe following mapping file can be used."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="xml" xmlNamespace="http://example.com/employeeFile">\n    <parser>\n      <property name="namespaces" value="n http://example.com/name"/>\n    </parser>\n    <record name="employee" class="example.Employee" xmlNamespace="http://example.com/employee" xmlPrefix="e">\n      <field name="firstName" xmlNamespace="http://example.com/name" />\n      <field name="lastName" xmlNamespace="http://example.com/name" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"From this example, the following behavior can be observed:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("inlineCode",{parentName:"li"},"xmlPrefix")," attribute can be used to assign a namespace prefix anywhere a ",(0,a.kt)("inlineCode",{parentName:"li"},"xmlNamespace")," is declared."),(0,a.kt)("li",{parentName:"ul"},"If a prefix is configured, the namespace is assigned to the prefix and the prefix is used from that point forward.\nThis can be seen on the 'employee' element (",(0,a.kt)("inlineCode",{parentName:"li"},"record")," configuration)."),(0,a.kt)("li",{parentName:"ul"},"If a prefix is not configured, a namespace declaration will replace the default namespace. This can be seen on the '\nemployeeFile' element (",(0,a.kt)("inlineCode",{parentName:"li"},"stream")," configuration)."),(0,a.kt)("li",{parentName:"ul"},"As previously mentioned, namespace are by default inherited from parent mapping elements. This can be seen on the '\ntitle', 'salary' and 'hireDate' elements (",(0,a.kt)("inlineCode",{parentName:"li"},"field")," configurations)."),(0,a.kt)("li",{parentName:"ul"},"Namespaces can be eagerly declared on the root element using the writer's ",(0,a.kt)("inlineCode",{parentName:"li"},"namespaces")," property. Multiple namespaces\ncan be declared with space delimiters such as '",(0,a.kt)("em",{parentName:"li"},"prefix1 namespace1 prefix2 namespace2..."),"'.")),(0,a.kt)("p",null,"BeanIO also supports a special wildcard namespace. If ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlNamespace")," is set to '","*","', any namespace is allowed when\nunmarshalling XML, and no namespace declaration will be made when marshalling XML."),(0,a.kt)("p",null,"The following table summarizes namespace configuration options and their effect on the configured element and a child\nthat inherits it's parent namespace."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Mapping Configuration"),(0,a.kt)("th",null,"Marshalled Element And Child")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,"[None]")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<element> <child/> </element>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'xmlNamespace="*"')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<element> <child/> </element>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'xmlNamespace=""')),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<element xmlns=""> <child/> </element>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'xmlNamespace="http://example.com"')),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<element xmlns="http://example.com"> <child/> </element>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'xmlNamespace="http://example.com" xmlPrefix="e"')),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<e:element xmlns="http://example.com"> <e:child/> </e:element>'))))),(0,a.kt)("h3",{id:"54-streams"},"5.4. Streams"),(0,a.kt)("p",null,"When unmarshalling multiple records from an XML document, the ",(0,a.kt)("inlineCode",{parentName:"p"},"stream")," configuration is mapped to the root element in\nthe XML formatted stream. This default behavior has been demonstrated in previous examples. If on the other hand, an XML\ndocument contains only a single record, the document can be fully read or written by setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"stream"),"\nconfiguration's ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," attribute to ",(0,a.kt)("inlineCode",{parentName:"p"},"none"),". This behavior is similar to other OXM libraries that marshall or\nunmarshall one bean object per XML document."),(0,a.kt)("p",null,"For example, if BeanIO was used to unmarshall a single employee record submitted via a web service, the XML document\nmight look like the following. Notice there is no 'employeeFile' root element for containing multiple employee records."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},"<employee>\n  <firstName>Joe</firstName>\n  <lastName>Smith</lastName>\n  <title>Developer</title>\n  <salary>75000</salary>\n  <hireDate>2009-10-12</hireDate>\n</employee>\n")),(0,a.kt)("p",null,"In this example, the following highlighted changes can be made to our mapping file to allow BeanIO to\nunmarshall/marshall a single employee record."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="xml" xmlType="none">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h3",{id:"55-groups"},"5.5. Groups"),(0,a.kt)("p",null,"Like other mapping elements, groups are also mapped to XML elements by default. Or if a group is used only for control\npurposes, the group's ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," attribute can be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"none"),"."),(0,a.kt)("h3",{id:"56-records"},"5.6. Records"),(0,a.kt)("p",null,"A record is always mapped to an XML element. As we've seen before, records are matched based on their group context and\nconfigured record identifying fields. XML records are further matched using their XML element name, as defined\nby ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlName"),", or if not present, ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),". Other than configured record identifying fields, segment and field names\ndeclared within the record are not used to identify records."),(0,a.kt)("p",null,"For example, let's suppose our employee file differentiated managers using 'manager' tags."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<employeeFile>\n  <employee>\n    <firstName>Joe</firstName>\n    <lastName>Smith</lastName>\n    <title>Developer</title>\n    <salary>75000</salary>\n    <hireDate>2009-10-12</hireDate>\n  </employee>\n  <employee>\n    <firstName>Jane</firstName>\n    <lastName>Doe</lastName>\n    <title>Architect</title>\n    <salary>80000</salary>\n    <hireDate>2008-01-15</hireDate>\n  </employee>\n  <manager>\n    <firstName>Jon</firstName>\n    <lastName>Andersen</lastName>\n    <title>Manager</title>\n    <salary>85000</salary>\n    <hireDate>2007-03-18</hireDate>\n  </manager>\n</employeeFile>\n')),(0,a.kt)("p",null,"To bind managers to a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Manager")," bean we could use the following mapping configuration."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="xml">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n    </record>\n    <record name="manager" class="example.Manager">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("h3",{id:"57-fields"},"5.7. Fields"),(0,a.kt)("p",null,"A field is mapped to XML using the field's ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," attribute, which defaults to ",(0,a.kt)("inlineCode",{parentName:"p"},"element"),". The field XML type can be\nset to ",(0,a.kt)("inlineCode",{parentName:"p"},"element"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"attribute"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"text"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"none"),". The following table illustrates possible configurations, except\nfor ",(0,a.kt)("inlineCode",{parentName:"p"},"none")," which is not covered here."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Record Definition"),(0,a.kt)("th",null,"Sample Record")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'xmlType="element"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<person> <name>John</name> </person>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'xmlType="attribute"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<person name="John"/>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'xmlType="text"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<person>John</person>"))))),(0,a.kt)("h4",{id:"571-field-type-conversion"},"5.7.1. Field Type Conversion"),(0,a.kt)("p",null,"Field type conversion works the same way for XML formatted streams as it does for other formats. However, several\ndefault type handlers are overridden specifically for XML formatted streams to conform with W3C XML Schema built-in data\ntypes according to this ",(0,a.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/xmlschema-2/"},"specification"),". The following table summarizes overriden\ntype handlers:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Class or Type Alias"),(0,a.kt)("th",null,"XML Schema Data Type"),(0,a.kt)("th",null,"Example")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"date",(0,a.kt)("br",null),"calendar-date")),(0,a.kt)("td",null,(0,a.kt)("a",{href:"http://www.w3.org/TR/xmlschema-2/#date"},"date")),(0,a.kt)("td",null,(0,a.kt)("code",null,"2011-01-01"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"datetime",(0,a.kt)("br",null),"java.util.Date",(0,a.kt)("br",null),"calendar",(0,a.kt)("br",null),"calendar-datetime",(0,a.kt)("br",null),"java.util.Calendar")),(0,a.kt)("td",null,(0,a.kt)("a",{href:"http://www.w3.org/TR/xmlschema-2/#dateTime"},"dateTime")),(0,a.kt)("td",null,(0,a.kt)("code",null,"2011-01-01T15:14:13"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"time",(0,a.kt)("br",null),"calendar-time")),(0,a.kt)("td",null,(0,a.kt)("a",{href:"http://www.w3.org/TR/xmlschema-2/#time"},"time")),(0,a.kt)("td",null,(0,a.kt)("code",null,"15:14:13"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"boolean")),(0,a.kt)("td",null,(0,a.kt)("a",{href:"http://www.w3.org/TR/xmlschema-2/#boolean"},"boolean")),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))))),(0,a.kt)("p",null,"Like other type handlers, XML specific type handlers can be customized or completely replaced. Please consult BeanIO\njavadocs for customization details."),(0,a.kt)("h4",{id:"572-marshalling-null-field-values"},"5.7.2. Marshalling Null Field Values"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"nillable")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," field attributes control how a null field value is marshalled. If ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," is 0, an\nelement or attribute is not marshalled for the field. If an element type field has ",(0,a.kt)("inlineCode",{parentName:"p"},"nillable")," set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," set to 1, the W3C XML Schema Instance attribute ",(0,a.kt)("inlineCode",{parentName:"p"},"nil")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,a.kt)("p",null,"This behavior is illustrated in the following table."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Field Type"),(0,a.kt)("th",null,"Record Definition"),(0,a.kt)("th",null,"Marshalled Record",(0,a.kt)("br",null),"(Field Value is Null)")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"3"},(0,a.kt)("pre",null,"element")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" /> </person>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<person> <name/> </person>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"')," /> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<person/>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'nillable="true"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<person> <name xsi:nil="true"/> </person>'))),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("pre",null,"attribute")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'xmlType="attribute"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<person/>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'xmlType="attribute" minOccurs="1"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<person name=""/>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,"text")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<record name="person" className="map"> <field name="name" ',(0,a.kt)("span",{className:"highlight"},'xmlType="text"'),"/> </person>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<person/>"))))),(0,a.kt)("h3",{id:"58-segments"},"5.8. Segments"),(0,a.kt)("p",null,"A segment can be used to bind a group of fields to a nested bean object, or to wrap a field or group of fields under an\nXML element."),(0,a.kt)("h4",{id:"581-nested-beans"},"5.8.1. Nested Beans"),(0,a.kt)("p",null,"Segments can be used to bind a group of fields to a bean object. The ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," assigned to the segment determines the\nformat of the XML. Possible values are ",(0,a.kt)("inlineCode",{parentName:"p"},"element")," (default) and ",(0,a.kt)("inlineCode",{parentName:"p"},"none"),". The difference can be explored using the Address\nand Employee beans defined in Section 4.4 and repeated here."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\n\npublic class Address {\n    String street;\n    String city;\n    String state;\n    String zip;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n    Address mailingAddress;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"By default, a segment's ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"element"),", so it is not necessary to declare it in the mapping file below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="xml">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n      <segment name="mailingAddress" class="example.Address" xmlType="element">\n        <field name="street" />\n        <field name="city" />\n        <field name="state" />\n        <field name="zip" />\n      </segment>\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"This mapping configuration can be used to process the sample XML document below. When a segment is mapped to an XML\nelement, ",(0,a.kt)("inlineCode",{parentName:"p"},"nillable")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," will control the marshalling behavior of null bean objects in the same fashion as a\nfield (see ",(0,a.kt)("a",{parentName:"p",href:"#NullFields"},"Section 5.7.2"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<employeeFile>\n  <employee>\n    <firstName>Joe</firstName>\n    <lastName>Smith</lastName>\n    <title>Developer</title>\n    <salary>75000</salary>\n    <hireDate>2009-10-12</hireDate>\n    <mailingAddress>\n      <street>123 Main Street</street>\n      <city>Chicago</city>\n      <state>IL</state>\n      <zip>12345</zip>\n    </mailingAddress>\n  </employee>\n  .\n  .\n  .\n</employeeFile>\n')),(0,a.kt)("p",null,"Alternatively, if the segment's ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"none"),", the following XML document can be processed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<employeeFile>\n  <employee>\n    <firstName>Joe</firstName>\n    <lastName>Smith</lastName>\n    <title>Developer</title>\n    <salary>75000</salary>\n    <hireDate>2009-10-12</hireDate>\n    <street>123 Main Street</street>\n    <city>Chicago</city>\n    <state>IL</state>\n    <zip>12345</zip>\n  </employee>\n  .\n  .\n  .\n</employeeFile>\n')),(0,a.kt)("h4",{id:"582-wrapped-segments"},"5.8.2. Wrapped Segments"),(0,a.kt)("p",null,"In some cases, an XML document may contain extraneous elements that do not map directly to a bean object or property\nvalue. In these cases, a ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," (without a ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," attribute) can be used to wrap a field or group of fields."),(0,a.kt)("p",null,"Extending the previous example, let's suppose the ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," bean object is modified to hold a list of addresses."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package example;\nimport java.util.Date;\n\npublic class Employee {\n    String firstName;\n    String lastName;\n    String title;\n    int salary;\n    Date hireDate;\n    List<Address> addressList;\n\n    // getters and setters not shown...\n}\n")),(0,a.kt)("p",null,"And let's further suppose that each employee's list of addresses is enclosed in a new element called ",(0,a.kt)("inlineCode",{parentName:"p"},"addresses"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<employeeFile>\n  <employee>\n    <firstName>Joe</firstName>\n    <lastName>Smith</lastName>\n    <title>Developer</title>\n    <salary>75000</salary>\n    <hireDate>2009-10-12</hireDate>\n    <addresses>\n      <mailingAddress>\n        <street>123 Main Street</street>\n        <city>Chicago</city>\n        <state>IL</state>\n        <zip>12345</zip>\n      </mailingAddress>\n    </addresses>\n  </employee>\n  .\n  .\n  .\n</employeeFile>\n')),(0,a.kt)("p",null,"The mapping file can now be updated as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="xml">\n    <record name="employee" class="example.Employee">\n      <field name="firstName" />\n      <field name="lastName" />\n      <field name="title" />\n      <field name="salary" />\n      <field name="hireDate" type="date" />\n      <segment name="addresses">\n        <segment name="mailingAddress" class="example.Address" collection="list" minOccurs="0" maxOccurs="unbounded">\n          <field name="street" />\n          <field name="city" />\n          <field name="state" />\n          <field name="zip" />\n        </segment>\n      </segment>\n    </record>\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"The following table illustrates various effects using a segment based on the ",(0,a.kt)("inlineCode",{parentName:"p"},"xmlType")," of a field, and the effect\nof ",(0,a.kt)("inlineCode",{parentName:"p"},"minOccurs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"nillable")," when marshalling null field values."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Field Mapping"),(0,a.kt)("th",null,"Non-Null Field Value"),(0,a.kt)("th",null,"Null Field Value")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" /> </segment>')),(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("pre",null,"<wrapper> <field>value</field> </wrapper>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<wrapper> <field/> </wrapper>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"'),'> <field name="field" /> </segment>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"-"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'nillable="true"'),'> <field name="field" /> </segment>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<wrapper xsi:nil="true"/>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" ',(0,a.kt)("span",{className:"highlight"},'nillable="true"')," /> </segment>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<wrapper> <field xsi:nil="true"/> </wrapper>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"'),"/> </segment>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<wrapper/>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" xmlType="attribute" /> </segment>')),(0,a.kt)("td",{rowSpan:"3"},(0,a.kt)("pre",null,'<wrapper field="value"/>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<wrapper/>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" xmlType="attribute" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="1"')," /> </segment>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<wrapper field=""/>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"'),'> <field name="field" xmlType="attribute" minOccurs="1" /> </segment>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"-"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" xmlType="text" /> </segment>')),(0,a.kt)("td",{rowSpan:"3"},(0,a.kt)("pre",null,"<wrapper>value</wrapper>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<wrapper/>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'nillable="true"'),'> <field name="field" xmlType="text" /> </segment>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<wrapper xsi:nil="true"/>'))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"'),'> <field name="field" xmlType="text"/> </segment>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"-"))))),(0,a.kt)("p",null,"Similarly, a ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," can be used to wrap a repeating field as illustrated below."),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Field Mapping"),(0,a.kt)("th",null,"Collection"),(0,a.kt)("th",null,"Null or Empty Collection")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" collection="list"',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"'),' maxOccurs="10" /> </segment name="wrapper">')),(0,a.kt)("td",{rowSpan:"4"},(0,a.kt)("pre",null,"<wrapper> <field>value1</field> <field>value2</field> </wrapper>")),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<wrapper />"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper"> <field name="field" collection="list"',(0,a.kt)("span",{className:"highlight"},'minOccurs="1"'),' maxOccurs="10" /> </wrapper>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"<wrapper> <field/> </wrapper>"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'minOccurs="0"'),'> <field name="field" collection="list" minOccurs="1" maxOccurs="10" /> </wrapper>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,"-"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("pre",null,'<segment name="wrapper" ',(0,a.kt)("span",{className:"highlight"},'nillable="true"'),'> <field name="field" collection="list" minOccurs="1" maxOccurs="10" /> </wrapper>')),(0,a.kt)("td",null,(0,a.kt)("pre",null,'<wrapper xsi:nil="true"/>'))))),(0,a.kt)("h2",{id:"60-annotations-and-the-stream-builder-api"},"6.0. Annotations and the Stream Builder API"),(0,a.kt)("p",null,"Since release 2.1, BeanIO includes support for Java annotations and a stream builder API."),(0,a.kt)("h3",{id:"61-the-stream-builder-api"},"6.1. The Stream Builder API"),(0,a.kt)("p",null,"The stream builder API can be used to programatically create a stream mapping without the need for a mapping file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'    StreamFactory factory = StreamFactory.newInstance();\n\n    // create a new StreamBuilder and define its layout\n    StreamBuilder builder = new StreamBuilder("employeeFile")\n        .format("delimited")\n        .parser(new DelimitedParserBuilder(\',\'))\n        .addRecord(new RecordBuilder("employee")\n            .type(Employee.class)\n            .minOccurs(1)\n            .addField(new FieldBuilder("type").rid().literal("EMP").ignore())\n            .addField(new FieldBuilder("recordType").rid(\n            .addField(new FieldBuilder("firstName"))\n            .addField(new FieldBuilder("lastName"))\n            .addField(new FieldBuilder("title"))\n            .addField(new FieldBuilder("salary"))\n            .addField(new FieldBuilder("hireDate").format("MMddyyyy")));\n\n    // pass the StreamBuilder to the factory\n    factory.define(builder);\n\n    BeanReader in = factory.createReader("employeeFile", new File("employee.csv"));\n    // etc...\n')),(0,a.kt)("p",null,"Like in a mapping file, components are assumed to be ordered as they are added to their parent, unless ",(0,a.kt)("inlineCode",{parentName:"p"},"at")," (for fields)\nor ",(0,a.kt)("inlineCode",{parentName:"p"},"order")," (for records and groups) is explicitly set. For more information, refer to the Javadocs for\nthe ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/builder/package-summary.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.builder"))," package."),(0,a.kt)("h3",{id:"62-annotations"},"6.2. Annotations"),(0,a.kt)("p",null,"Java classes can also be annotated to augment the use of the stream builder API or mapping file. Classes may be\nannotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@Record"),", and class attributes or getter/setter methods may be annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@Field"),". Any component\nannotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@Record")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"@Segment")," may be further annotated using ",(0,a.kt)("inlineCode",{parentName:"p"},"@Fields")," to include fields not bound to a Java\nproperty."),(0,a.kt)("p",null,"Continuing our previous example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"example.Employee")," class could be annotated like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'@Record(minOccurs=1}\n@Fields({\n    @Field(name="type", at=0, rid=true, literal="EMP")\n})\npublic class Employee {\n\n    @Field(at=1)\n    private String firstName;\n    @Field(at=2)\n    private String lastName;\n    @Field(at=3)\n    private String title;\n    @Field(at=4)\n    private String salary,\n    @Field(at=5, format="MMddyyyy")\n    private Date hireDate;\n\n    // getters and setters...\n}\n')),(0,a.kt)("p",null,"Using an annotated ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee")," class, the stream builder example can be greatly simplified:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'    StreamFactory factory = StreamFactory.newInstance();\n\n    StreamBuilder builder = new StreamBuilder("employeeFile")\n        .format("delimited")\n        .parser(new DelimitedParserBuilder(\',\'))\n        .addRecord(Employee.class);\n\n    factory.define(builder);\n')),(0,a.kt)("p",null,"As can a mapping file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio>\n\n  <stream name="employeeFile" format="delimited">\n    <parser>\n      <property name="delimiter" value="," />\n    </parser>\n    <record name="employee" class="example.Employee" />\n  </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"When using annotations, it is strongly recommended to explicitly set the position (using ",(0,a.kt)("inlineCode",{parentName:"p"},"at"),") for all fields and\nsegments. BeanIO does not guarrantee the order in which annotated components are added to a layout."),(0,a.kt)("p",null,"Annotation settings are generally named according to their mapping file counterparts and follow the same convention as\nwell. Refer to ",(0,a.kt)("a",{parentName:"p",href:"#A"},"Appendix A")," for a complete explanation of all settings."),(0,a.kt)("p",null,"Where used, annotated records can not be overridden by mapping file components. Configuration settings other\nthan ",(0,a.kt)("inlineCode",{parentName:"p"},"class")," and descendent components will be ignored."),(0,a.kt)("h2",{id:"80-configuration"},"8.0. Configuration"),(0,a.kt)("p",null,"In some cases, BeanIO behavior can be controlled by setting optional property values. Properties can be set using System\nproperties or a property file. BeanIO will load configuration setting in the following order of priority:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"System properties."),(0,a.kt)("li",{parentName:"ol"},"A property file named ",(0,a.kt)("inlineCode",{parentName:"li"},"beanio.properties"),". The file will be looked for first in the application's working directory,\nand then on the classpath.")),(0,a.kt)("p",null,"The name and location of ",(0,a.kt)("inlineCode",{parentName:"p"},"beanio.properties")," can be overridden using the System property ",(0,a.kt)("inlineCode",{parentName:"p"},"org.beanio.configuration"),". In\nthe following example, configuration settings will be loaded from the file named ",(0,a.kt)("inlineCode",{parentName:"p"},"config/settings.properties"),", first\nrelative to the application's working directory, and if not found, then from the root of the application's classpath."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"java -Dorg.beanio.configuration=config/settings.properties example.Main\n")),(0,a.kt)("h3",{id:"81-settings"},"8.1. Settings"),(0,a.kt)("p",null,"The following configuration settings are supported by BeanIO:"),(0,a.kt)("table",{className:"indent"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Property"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Default")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.allowProtectedAccess")),(0,a.kt)("td",null,"Whether private and protected class variables and constructors can be accessed (i.e. make accessible using the reflection API)."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.lazyIfEmpty")),(0,a.kt)("td",null,"Whether objects are lazily instantiated if String properties are empty (and not just null)."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.errorIfNullPrimitive")),(0,a.kt)("td",null,"Whether null field values will cause an exception if bound to a primitive property."),(0,a.kt)("td",null,(0,a.kt)("code",null,"false"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.useDefaultIfMissing")),(0,a.kt)("td",null,"Whether default values apply to fields missing from the stream."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.propertyEscapingEnabled")),(0,a.kt)("td",null,"Whether ",(0,a.kt)("a",{href:"#property"},(0,a.kt)("code",null,"property"))," values (for ",(0,a.kt)("code",null,"typeHandler"),", ",(0,a.kt)("code",null,"reader"),"and ",(0,a.kt)("code",null,"writer")," elements) support escape patterns for line feeds, carriage returns, tabs, etc. Set to ",(0,a.kt)("code",null,"true")," or ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.nullEscapingEnabled")),(0,a.kt)("td",null,"Whether the null character can be escaped using ",(0,a.kt)("code",null,"\\0")," when property escaping is enabled. Set to ",(0,a.kt)("code",null,"true")," or ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.marshalDefaultEnabled")),(0,a.kt)("td",null,"Whether a configured ",(0,a.kt)("a",{href:"#field"},(0,a.kt)("code",null,"field"))," default is marshalled for null property values. May be disabled for backwards compatibility by setting the value to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.defaultTypeHandlerLocale")),(0,a.kt)("td",null,"Sets the default type handler locale."),(0,a.kt)("td",null,(0,a.kt)("code",null,"Locale.getDefault()"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.defaultDateFormat")),(0,a.kt)("td",null,"Sets the default ",(0,a.kt)("code",null,"SimpleDateFormat")," pattern for ",(0,a.kt)("code",null,"date")," and",(0,a.kt)("code",null,"calendar-date")," type fields in CSV, delimited and fixed length file formats."),(0,a.kt)("td",null,(0,a.kt)("code",null,"DateFormat. getDateInstance()"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.defaultDateTimeFormat")),(0,a.kt)("td",null,"Sets the default ",(0,a.kt)("code",null,"SimpleDateFormat")," pattern for ",(0,a.kt)("code",null,"datetime"),",",(0,a.kt)("code",null,"calendar-datetime")," and ",(0,a.kt)("code",null,"calendar")," type fields in CSV, delimited and fixed length file formats.."),(0,a.kt)("td",null,(0,a.kt)("code",null,"DateFormat. getDateTimeInstance()"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.defaultTimeFormat")),(0,a.kt)("td",null,"Sets the default ",(0,a.kt)("code",null,"SimpleDateFormat")," pattern for ",(0,a.kt)("code",null,"time")," and",(0,a.kt)("code",null,"calendar-time")," type fields in CSV, delimited and fixed length file formats.."),(0,a.kt)("td",null,(0,a.kt)("code",null,"DateFormat. getTimeInstance()"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.group.minOccurs")),(0,a.kt)("td",null,"Sets the default ",(0,a.kt)("code",null,"minOccurs")," for a ",(0,a.kt)("a",{href:"#group"},(0,a.kt)("code",null,"group")),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"0"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.record.minOccurs")),(0,a.kt)("td",null,"Sets the default ",(0,a.kt)("code",null,"minOccurs")," for a ",(0,a.kt)("a",{href:"#record"},(0,a.kt)("code",null,"record")),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"0"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.field.minOccurs.[format]")),(0,a.kt)("td",null,"Sets the default ",(0,a.kt)("code",null,"minOccurs")," for a ",(0,a.kt)("a",{href:"#field"},(0,a.kt)("code",null,"field"))," by stream format."),(0,a.kt)("td",null,(0,a.kt)("code",null,"1"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.propertyAccessorFactory ")),(0,a.kt)("td",null,"Sets the method of property invocation to use. Defaults to ",(0,a.kt)("code",null,"reflection"),".")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.xml.defaultXmlType")),(0,a.kt)("td",null,"Sets the default XML type for a field in an XML formatted stream.  May be set to ",(0,a.kt)("code",null,"element")," or ",(0,a.kt)("code",null,"attribute"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"element"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.xml.xsiNamespacePrefix")),(0,a.kt)("td",null,"Sets the default prefix for the namespace ",(0,a.kt)("code",null,"http://www.w3.org/2001/XMLSchema-instance"),"."),(0,a.kt)("td",null,(0,a.kt)("code",null,"xsi"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"org.beanio.xml.sorted")),(0,a.kt)("td",null,"Whether XML fields are sorted by position (if assigned)."),(0,a.kt)("td",null,(0,a.kt)("code",null,"true"))))),(0,a.kt)("h2",{id:"appendix-a-xml-mapping-file-reference"},"Appendix A: XML Mapping File Reference"),(0,a.kt)("p",null,"Appendix A is the complete reference for the BeanIO 2.x XML mapping file schema. The root element of a mapping file\nis ",(0,a.kt)("inlineCode",{parentName:"p"},"[beanio](#beanio)")," with namespace ",(0,a.kt)("inlineCode",{parentName:"p"},"http://www.beanio.org/2012/03"),". The following notation is used to indicate the\nallowed number of child elements:"),(0,a.kt)("p",null,"*"," Zero, one or more",(0,a.kt)("br",{parentName:"p"}),"\n","+"," One or more",(0,a.kt)("br",{parentName:"p"}),"\n","? Zero or one"),(0,a.kt)("h5",{id:"ranges"},"Ranges"),(0,a.kt)("p",null,"Where noted, some attributes can be configured using a range notation. A range is expressed using the following syntax,\nwhere N and M are integer values:"),(0,a.kt)("table",{className:"indent",border:"0"},(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("td",null,"N"),(0,a.kt)("td",null,"Upper and lower boundaries are set to N.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"N-M"),(0,a.kt)("td",null,"Lower boundery is set to N.  Upper boundary is set to M.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"N+"),(0,a.kt)("td",null,"Lower boundary is set to N.  No upper boundary.")))),(0,a.kt)("h3",{id:"a1-beanio"},"A.1. ",(0,a.kt)("inlineCode",{parentName:"h3"},"beanio")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"beanio")," element is the root element for a BeanIO mapping file."),(0,a.kt)("p",null,"Children: ",(0,a.kt)("a",{parentName:"p",href:"#property"},(0,a.kt)("inlineCode",{parentName:"a"},"property")),"*",", ",(0,a.kt)("a",{parentName:"p",href:"#import"},(0,a.kt)("inlineCode",{parentName:"a"},"import")),"*",", ",(0,a.kt)("a",{parentName:"p",href:"#typeHandler"},(0,a.kt)("inlineCode",{parentName:"a"},"typeHandler")),"*",", ",(0,a.kt)("a",{parentName:"p",href:"#template"},(0,a.kt)("inlineCode",{parentName:"a"},"template")),"\n","*",", ",(0,a.kt)("a",{parentName:"p",href:"#stream"},(0,a.kt)("inlineCode",{parentName:"a"},"stream")),"*"),(0,a.kt)("h3",{id:"a2-import"},"A.2. ",(0,a.kt)("inlineCode",{parentName:"h3"},"import")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"import")," element is used to import type handlers, templates and streams from an external mapping file. Streams\ndeclared in a mapping file being imported are not affected by global type handlers or templates declared in the file\nthat imported it."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"resource")),(0,a.kt)("td",null,"The name of the resource to import.",(0,a.kt)("p",null,"The resource name must be qualified with 'classpath:' to load the resource from the classpath, or with 'file:' to load the file relative to the application's working directory.")),(0,a.kt)("td",null,"Yes")))),(0,a.kt)("h3",{id:"a3-typehandler"},"A.3. ",(0,a.kt)("inlineCode",{parentName:"h3"},"typeHandler")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"typeHandler")," element is used to declare a custom field type handler that implements\nthe ",(0,a.kt)("a",{parentName:"p",href:"https://beanio.github.io/api/org/beanio/types/TypeHandler.html"},(0,a.kt)("inlineCode",{parentName:"a"},"org.beanio.types.TypeHandler"))," interface. A type\nhandler can be registered for a specific Java type, or registered for a Java type and stream format combination, or\nexplicitly named."),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The type handler name.  A ",(0,a.kt)("a",{href:"#field"},"field")," can always reference a type handler by name, even if the stream format does not match the configured type handler ",(0,a.kt)("code",null,"format")," attribute.",(0,a.kt)("p",null,"When configured, the name of a globally declared type handler must be unique within a mapping and any imported mapping files.")),(0,a.kt)("td",null,"One of ",(0,a.kt)("code",null,"name")," or ",(0,a.kt)("code",null,"type")," is required.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"type")),(0,a.kt)("td",null,"The fully qualified classname or type alias to register the type handler for. If ",(0,a.kt)("code",null,"format")," is also set, the type handler will only be used by streams that match the configured format."),(0,a.kt)("td",null,"One of ",(0,a.kt)("code",null,"name")," or ",(0,a.kt)("code",null,"type")," is required.")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"class")),(0,a.kt)("td",null,"The fully qualified classname of the ",(0,a.kt)("code",null,"TypeHandler")," implementation."),(0,a.kt)("td",null,"Yes")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"format")),(0,a.kt)("td",null,"When used in conjunction with the ",(0,a.kt)("code",null,"type")," attribute, a type handler can be registered for a specific stream format.  Set to ",(0,a.kt)("code",null,"xml"),", ",(0,a.kt)("code",null,"csv"),",",(0,a.kt)("code",null,"delimited"),", or ",(0,a.kt)("code",null,"fixedlength"),".  If not set, the type handler may be used by any stream format."),(0,a.kt)("td",null,"No")))),(0,a.kt)("p",null,"Children: ",(0,a.kt)("a",{parentName:"p",href:"#property"},(0,a.kt)("inlineCode",{parentName:"a"},"property")),"*"),(0,a.kt)("h3",{id:"a4-property"},"A.4. ",(0,a.kt)("inlineCode",{parentName:"h3"},"property")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"property")," element has several uses."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"When used at the top of a mapping file as a direct child of ",(0,a.kt)("a",{parentName:"li",href:"#beanio"},(0,a.kt)("inlineCode",{parentName:"a"},"beanio")),", a ",(0,a.kt)("inlineCode",{parentName:"li"},"property")," may declare properties\nto use for property substitution in other attributes within the mapping file. Property substitution uses the\nsyntax ","`","${propertyName,default}","`",", where all whitespace between the brackets is retained. Properties cannot be\nimported from another file."),(0,a.kt)("li",{parentName:"ol"},"Or, a ",(0,a.kt)("inlineCode",{parentName:"li"},"property")," element may be used to customize other elements, such as a ",(0,a.kt)("a",{parentName:"li",href:"#typeHandler"},(0,a.kt)("inlineCode",{parentName:"a"},"typeHandler")),"\nor ",(0,a.kt)("a",{parentName:"li",href:"#parser"},(0,a.kt)("inlineCode",{parentName:"a"},"parser")),"."),(0,a.kt)("li",{parentName:"ol"},"Or finally, a ",(0,a.kt)("inlineCode",{parentName:"li"},"property")," value can be used to set constant values on a bean object, which is further described below.")),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The property name."),(0,a.kt)("td",null,"Yes")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"value")),(0,a.kt)("td",null,"The property value.",(0,a.kt)("p",null,"When used to customize a ",(0,a.kt)("a",{href:"#typeHandler"},(0,a.kt)("code",null,"typeHandler")),"or ",(0,a.kt)("a",{href:"#parser"},(0,a.kt)("code",null,"parser")),", default type handlers only are used to convert property text to an object value.  String and Character type property values can use the following escape sequences: ",(0,a.kt)("code",null,"\\\\")," (Backslash), ",(0,a.kt)("code",null,"\\n")," (Line Feed), ",(0,a.kt)("code",null,"\\r")," (Carriage Return), ",(0,a.kt)("code",null,"\\t")," (Tab),",(0,a.kt)("code",null,"\\0")," (Null) and ",(0,a.kt)("code",null,"\\f")," (Form Feed).  A backslash preceding any other character is ignored.")),(0,a.kt)("td",null,"Yes")))),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"property")," element, when used as child of a ",(0,a.kt)("a",{parentName:"p",href:"#record"},(0,a.kt)("inlineCode",{parentName:"a"},"record"))," or ",(0,a.kt)("a",{parentName:"p",href:"#segment"},(0,a.kt)("inlineCode",{parentName:"a"},"segment"))," element, can be used to set\nconstant values on a record or bean object that do not map to a field in the input or output stream. The following\nadditional attributes are accepted in this scenario:"),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Format(s)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"getter")),(0,a.kt)("td",null,"The getter method used to retrieve the property value from its parent bean class. By default, the getter method is determined through introspection using the property name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"setter")),(0,a.kt)("td",null,"The setter method used to set the property value on its parent bean class. By default, the setter method is determined through introspection using the property name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"rid")),(0,a.kt)("td",null,"Record identifier indicator for marshalling/writing only.  Set to ",(0,a.kt)("code",null,"true")," if this property is used to identify the record mapping configuration used to marshall a bean object. More than one property or field can be used for identification.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"type")),(0,a.kt)("td",null,"The fully qualified class name or type alias of the property value.  By default, BeanIO will derive the property type from the bean class.  This attribute can be used to override the default or may be required if the bean class is of type ",(0,a.kt)("code",null,"Map"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"typeHandler")),(0,a.kt)("td",null,"The name of the type handler to use for type conversion.  By default, BeanIO will select a type handler based on ",(0,a.kt)("code",null,"type")," when set, or through introspection of the property's parent bean class."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"format")),(0,a.kt)("td",null,"The decimal format pattern for ",(0,a.kt)("code",null,"Number")," type properties, or the simple date format pattern for ",(0,a.kt)("code",null,"Date")," type properties.",(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,"format")," value can accessed by any custom type handler that implements ",(0,a.kt)("code",null,"ConfigurableTypeHandler"),".")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")))),(0,a.kt)("h3",{id:"a5-template"},"A.5. ",(0,a.kt)("inlineCode",{parentName:"h3"},"template")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"template")," element is used to create reusable lists of bean properties."),(0,a.kt)("p",null,'Note that templates are "expanded" at the time they are included. This means an imported template that relies on\nproperty substitution will use property values from the mapping file that included it and not the mapping file where the\ntemplate was declared.'),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The name of the template.  Template names must be unique within a mapping file and any imported mapping files."),(0,a.kt)("td",null,"Yes")))),(0,a.kt)("p",null,"Children: ( ",(0,a.kt)("a",{parentName:"p",href:"#field"},(0,a.kt)("inlineCode",{parentName:"a"},"field"))," | ",(0,a.kt)("a",{parentName:"p",href:"#property"},(0,a.kt)("inlineCode",{parentName:"a"},"property"))," | ",(0,a.kt)("a",{parentName:"p",href:"#segment"},(0,a.kt)("inlineCode",{parentName:"a"},"segment"))," | ",(0,a.kt)("a",{parentName:"p",href:"#include"},(0,a.kt)("inlineCode",{parentName:"a"},"include"))," )","*"),(0,a.kt)("h3",{id:"a6-include"},"A.6. ",(0,a.kt)("inlineCode",{parentName:"h3"},"include")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"include")," element is used to include a template in a ",(0,a.kt)("a",{parentName:"p",href:"#record"},(0,a.kt)("inlineCode",{parentName:"a"},"record")),", ",(0,a.kt)("a",{parentName:"p",href:"#segment"},(0,a.kt)("inlineCode",{parentName:"a"},"segment")),", or\nanother ",(0,a.kt)("a",{parentName:"p",href:"#template"},(0,a.kt)("inlineCode",{parentName:"a"},"template")),"."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"template")),(0,a.kt)("td",null,"The name of the template to include."),(0,a.kt)("td",null,"Yes")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"offset")),(0,a.kt)("td",null,"The offset added to field positions included by the template.  Defaults to 0. "),(0,a.kt)("td",null,"No")))),(0,a.kt)("h3",{id:"a7-stream"},"A.7. ",(0,a.kt)("inlineCode",{parentName:"h3"},"stream")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"stream")," element defines the record layout of an input or output stream."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Format(s)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The name of the stream."),(0,a.kt)("td",null,"Yes"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"format")),(0,a.kt)("td",null,"The stream format.  Either ",(0,a.kt)("code",null,"xml"),", ",(0,a.kt)("code",null,"csv"),", ",(0,a.kt)("code",null,"delimited")," or",(0,a.kt)("code",null,"fixedlength")),(0,a.kt)("td",null,"Yes"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"mode")),(0,a.kt)("td",null,"By default, a stream mapping can be used for both reading input streams and writing output streams, called ",(0,a.kt)("code",null,"readwrite")," mode.  Setting mode to ",(0,a.kt)("code",null,"read")," or",(0,a.kt)("code",null,"write")," instead, respectively restricts usage to a ",(0,a.kt)("code",null,"BeanReader")," or a",(0,a.kt)("code",null,"BeanWriter")," only, but relaxes some validations on the mapping configuration.",(0,a.kt)("p",null,"When mode is set to ",(0,a.kt)("code",null,"read"),", a bean class does not require getter methods. "),(0,a.kt)("p",null,"When mode is set to ",(0,a.kt)("code",null,"write"),", a bean class may be abstract or an interface, and does not require setter methods.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"resourceBundle")),(0,a.kt)("td",null,"The name of the resource bundle for customizing error messages."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"strict")),(0,a.kt)("td",null,"When set to ",(0,a.kt)("code",null,"true"),", BeanIO will calculate and enforce record ordering based on the order records are declared.  The record ",(0,a.kt)("code",null,"order")," attribute can still be used to override a particular section of the stream.",(0,a.kt)("p",null,"When set to ",(0,a.kt)("code",null,"true"),", BeanIO will also calculate and enforce record lengths based on configured fields and their occurrences.  The record ",(0,a.kt)("code",null,"minLength"),"and ",(0,a.kt)("code",null,"maxLength")," attributes can still be used to override BeanIO defaults."),(0,a.kt)("p",null,"Defaults to ",(0,a.kt)("code",null,"false"),".")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"The minimum number of times the record layout must be read from an input stream.  Defaults to ",(0,a.kt)("code",null,"0"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxOccurs")),(0,a.kt)("td",null,"The maximum number of times the record layout can repeat when read from an input stream.  Defaults to ",(0,a.kt)("code",null,"1"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occurs")),(0,a.kt)("td",null,"An alternative to specifying both ",(0,a.kt)("code",null,"minOccurs")," and ",(0,a.kt)("code",null,"maxOccurs"),"that uses ",(0,a.kt)("a",{href:"#range"},"range notation"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"ignoreUnidentified Records")),(0,a.kt)("td",null,"If set to true, BeanIO will skip records that cannot be identified, otherwise an ",(0,a.kt)("code",null,"UnidentifiedRecordException")," is thrown.  This feature is not recommended for use with record groups, since a record sequencing error could cause large portions of a stream to go unprocessed without any exception."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlType")),(0,a.kt)("td",null,"The XML node type mapped to the stream. If not specified or set to ",(0,a.kt)("code",null,"element"),", the stream is mapped to the root element of the XML document being marshalled or unmarshalled.  If set to ",(0,a.kt)("code",null,"none"),", the XML input stream will be fully read and mapped to a child ",(0,a.kt)("a",{href:"#group"},(0,a.kt)("code",null,"group"))," or",(0,a.kt)("a",{href:"#record"},(0,a.kt)("code",null,"record")),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlName")),(0,a.kt)("td",null,"The local name of the XML element mapped to the stream.  Defaults to the stream name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlNamespace")),(0,a.kt)("td",null,"The namespace of the XML element mapped to the stream.  Defaults to '*' which will ignore namespaces while marshalling and unmarshalling."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlPrefix")),(0,a.kt)("td",null,"The namespace prefix assigned to the declared ",(0,a.kt)("code",null,"xmlNamespace")," for marshalling XML. If not specified, the default namespace (i.e. ",(0,a.kt)("code",null,'xmlns="..."'),") is used."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")))),(0,a.kt)("p",null,"Children: ",(0,a.kt)("a",{parentName:"p",href:"#parser"},(0,a.kt)("inlineCode",{parentName:"a"},"parser")),"?, ",(0,a.kt)("a",{parentName:"p",href:"#typeHandler"},(0,a.kt)("inlineCode",{parentName:"a"},"typeHandler")),"*",", ( ",(0,a.kt)("a",{parentName:"p",href:"#record"},(0,a.kt)("inlineCode",{parentName:"a"},"record"))," | ",(0,a.kt)("a",{parentName:"p",href:"#group"},(0,a.kt)("inlineCode",{parentName:"a"},"group"))," )+"),(0,a.kt)("h3",{id:"a8-parser"},"A.8. ",(0,a.kt)("inlineCode",{parentName:"h3"},"parser")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"parser")," element is used to customize or replace the default record parser factory for a stream."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"class")),(0,a.kt)("td",null,"The fully qualified class name of the ",(0,a.kt)("a",{href:"/api/org/beanio/stream/RecordParserFactory.html"},(0,a.kt)("code",null,"org.beanio.stream.RecordParserFactory"))," implementation to use for this stream.  If not specified, one of the following default factories is used based on the stream format:",(0,a.kt)("br",null),(0,a.kt)("br",null),"csv - ",(0,a.kt)("a",{href:"/api/org/beanio/stream/csv/CsvRecordParserFactory.html"},(0,a.kt)("code",null,"org.beanio.stream.csv.CsvRecordParserFactory")),(0,a.kt)("br",null),"delimited - ",(0,a.kt)("a",{href:"/api/org/beanio/stream/delimited/DelimitedRecordParserFactory.html"},(0,a.kt)("code",null,"org.beanio.stream.delimited.DelimitedRecordParserFactory")),(0,a.kt)("br",null),"fixedlength - ",(0,a.kt)("a",{href:"/api/org/beanio/stream/fixedlength/FixedLengthRecordParserFactory.html"},(0,a.kt)("code",null,"org.beanio.stream.fixedlength.FixedLengthRecordParserFactory")),(0,a.kt)("br",null),"xml - ",(0,a.kt)("a",{href:"/api/org/beanio/stream/xml/XmlRecordParserFactory.html"},(0,a.kt)("code",null,"org.beanio.stream.xml.XmlRecordParserFactory")),(0,a.kt)("p",null,"Overriding the record parser factory for XML is not supported (but also not prevented).")),(0,a.kt)("td",null,"No")))),(0,a.kt)("p",null,"Children: ",(0,a.kt)("a",{parentName:"p",href:"#property"},(0,a.kt)("inlineCode",{parentName:"a"},"property")),"*"),(0,a.kt)("h3",{id:"a9-group"},"A.9. ",(0,a.kt)("inlineCode",{parentName:"h3"},"group")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"group")," element is used to group records together for validating occurrences of the group as a whole."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Format(s)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The name of the group."),(0,a.kt)("td",null,"Yes"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"class")),(0,a.kt)("td",null,"The fully qualified class name of the bean object mapped to this group.  A ",(0,a.kt)("code",null,"class"),"may be bound to a group when its marshalled form spans multiple consecutive records.",(0,a.kt)("p",null,"During umarshalling, if any record in the group fails validation, an",(0,a.kt)("code",null,"InvalidRecordGroupException")," is thrown.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"value",(0,a.kt)("br",null),(0,a.kt)("del",null,"target"))),(0,a.kt)("td",null,"The name of a child component (typically a record) to return in lieu of an assigned class.",(0,a.kt)("p",null,"There can be only one iteration of the named value.  For example, if a repeating segment bound to a collection contains a repeating field (also bound to a collection), the segment can be targeted, but the field cannot.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"collection")),(0,a.kt)("td",null,"The collection type for repeating groups bound to a parent bean object (configured on a ",(0,a.kt)("a",{href:"#group"},(0,a.kt)("code",null,"group")),").  The value may be set to any fully qualified class name assignable to ",(0,a.kt)("code",null,"java.util.Collection"),", or to one of the collection type aliases: ",(0,a.kt)("code",null,"list"),", ",(0,a.kt)("code",null,"set")," or ",(0,a.kt)("code",null,"array"),". A collection type can only be set if ",(0,a.kt)("code",null,"class")," is also set.",(0,a.kt)("p",null,"BeanIO will not derive the collection type from it's parent bean object.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"getter")),(0,a.kt)("td",null,"The getter method used to get the bean object bound to this group from it's parent.  By default, the getter method is determined through introspection using the group name.  Ignored if ",(0,a.kt)("code",null,"class")," is not set."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"setter")),(0,a.kt)("td",null,"The setter method used to set the bean object bound to this group on the bean object of it's parent.  By default, the setter method is determined through introspection using the group name.  Ignored if ",(0,a.kt)("code",null,"class")," is not set."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"order")),(0,a.kt)("td",null,"The order this group must appear within its parent group or stream.",(0,a.kt)("p",null,"If ",(0,a.kt)("code",null,"strict")," is set to true at the stream level, ",(0,a.kt)("code",null,"order")," will default to the order assigned to its preceding sibling plus one (i.e. the record or group that shares the same parent), or 1 if this group is the first child in its parent group or stream. If ",(0,a.kt)("code",null,"strict")," is false, defaults to 1."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<p>If <code>order</code> is explicitly set for one group, it must be set for all other siblings\nthat share the same parent.</p>\n"))),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"The minimum number of occurences of this group within its parent group or stream. Defaults to 1."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxOccurs")),(0,a.kt)("td",null,"The maximum number of occurences of this group within its parent group or stream. Defaults to ",(0,a.kt)("code",null,"unbounded"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occurs")),(0,a.kt)("td",null,"An alternative to specifying both ",(0,a.kt)("code",null,"minOccurs")," and ",(0,a.kt)("code",null,"maxOccurs"),"that uses ",(0,a.kt)("a",{href:"#range"},"range notation"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlType")),(0,a.kt)("td",null,"The XML node type mapped to this group. If not specified or set to ",(0,a.kt)("code",null,"element"),", this group is mapped to an XML element.  When set to",(0,a.kt)("code",null,"none"),", this group is used only to define expected record sequencing."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlName")),(0,a.kt)("td",null,"The local name of the XML element mapped to this group.  Defaults to the group name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlNamespace")),(0,a.kt)("td",null,"The namespace of the XML element mapped to this group.  Defaults to the namespace declared for the parent stream or group definition."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlPrefix")),(0,a.kt)("td",null,"The namespace prefix assigned to the declared ",(0,a.kt)("code",null,"xmlNamespace")," for marshalling XML. If not specified, the default namespace is used (i.e. ",(0,a.kt)("code",null,'xmlns="..."'),")."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")))),(0,a.kt)("p",null,"Children: ",(0,a.kt)("a",{parentName:"p",href:"#record"},(0,a.kt)("inlineCode",{parentName:"a"},"record")),"*"),(0,a.kt)("h3",{id:"a10-record"},"A.10. ",(0,a.kt)("inlineCode",{parentName:"h3"},"record")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"record")," is used to define a record mapping within a stream."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Format(s)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The name of the record."),(0,a.kt)("td",null,"Yes"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"class")),(0,a.kt)("td",null,"The fully qualified class name of the bean object mapped to this record.",(0,a.kt)("p",null,"If set to ",(0,a.kt)("code",null,"map")," or any ",(0,a.kt)("code",null,"java.util.Map")," implementation, a Map object will be used with field names for keys and field values for values."),(0,a.kt)("p",null,"If set to ",(0,a.kt)("code",null,"list"),", ",(0,a.kt)("code",null,"set"),", ",(0,a.kt)("code",null,"collection"),", or any ",(0,a.kt)("code",null,"java.util.Collection"),"implementation, child fields are added to the declared collection, including null values for missing or null fields."),(0,a.kt)("p",null,"If neither ",(0,a.kt)("code",null,"class")," or ",(0,a.kt)("code",null,"target")," is set, a ",(0,a.kt)("code",null,"BeanReader")," will fully validate the record, but no bean object will be returned and the reader will continue reading the next record.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"value",(0,a.kt)("br",null),(0,a.kt)("del",null,"target"))),(0,a.kt)("td",null,"The name of a child segment or field to return in lieu of an assigned class.",(0,a.kt)("p",null,"There can be only one iteration of a named value.  For example, if a repeating segment bound to a collection contains a repeating field (also bound to a collection), the segment can be targeted, but the field cannot."),(0,a.kt)("p",null,"If neither ",(0,a.kt)("code",null,"class")," or ",(0,a.kt)("code",null,"value")," is set, a ",(0,a.kt)("code",null,"BeanReader")," will fully validate the record, but no bean object will be returned and the reader will continue reading the next record.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"getter")),(0,a.kt)("td",null,"The getter method used to get the bean object bound to this record from it's parent.  By default, the getter method is determined through introspection using the record name.  Ignored if ",(0,a.kt)("code",null,"class")," is not set."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"setter")),(0,a.kt)("td",null,"The setter method used to set the bean object bound to this record on the bean object of it's parent.  By default, the setter method is determined through introspection using the record name.  Ignored if ",(0,a.kt)("code",null,"class")," is not set."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"collection")),(0,a.kt)("td",null,"The collection type for repeating records bound to a parent bean object (configured on a ",(0,a.kt)("a",{href:"#group"},(0,a.kt)("code",null,"group")),").  The value may be set to any fully qualified class name assignable to ",(0,a.kt)("code",null,"java.util.Collection")," or ",(0,a.kt)("code",null,"java.util.Map"),", or to one of the collection type aliases: ",(0,a.kt)("code",null,"list"),", ",(0,a.kt)("code",null,"set"),", ",(0,a.kt)("code",null,"map")," or ",(0,a.kt)("code",null,"array"),". A collection type can only be set if ",(0,a.kt)("code",null,"class")," or ",(0,a.kt)("code",null,"target")," is also set.",(0,a.kt)("p",null,"BeanIO will not derive the collection type from it's parent bean object.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"key")),(0,a.kt)("td",null,"The name of a descendant field to use for the Map key when ",(0,a.kt)("code",null,"collection"),"is assignable to a ",(0,a.kt)("code",null,"java.util.Map"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"order")),(0,a.kt)("td",null,"The order this record must appear within its parent group or stream.",(0,a.kt)("p",null,"If ",(0,a.kt)("code",null,"strict")," is set to true at the stream level, ",(0,a.kt)("code",null,"order")," will default to the order assigned to its preceding sibling plus one (i.e. the record or group that shares the same parent), or 1 if this record is the first child in its parent group or stream. If ",(0,a.kt)("code",null,"strict")," is false, defaults to 1."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<p>If <code>order</code> is explicitly set for one record, it must be set for all other siblings\nthat share the same parent.</p>\n"))),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"The minimum number of occurences of this record within its parent group or stream. Defaults to 0."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxOccurs")),(0,a.kt)("td",null,"The maximum number of occurrences of this record within its parent group or stream. Defaults to ",(0,a.kt)("code",null,"unbounded"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occurs")),(0,a.kt)("td",null,"An alternative to specifying both ",(0,a.kt)("code",null,"minOccurs")," and ",(0,a.kt)("code",null,"maxOccurs"),"that uses ",(0,a.kt)("a",{href:"#range"},"range notation"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lazy")),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", the class or collection bound to this record will only be instantiated if at least one child attribute is not null or the empty String. Defaults to ",(0,a.kt)("code",null,"false"),".  [Only applies if this record is bound to an attribute of a parent group.]"),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"template")),(0,a.kt)("td",null,"The name of the template to include.  The template is added to the record layout before any child of this record."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"ridLength")),(0,a.kt)("td",null,"The expected length of this record for identifying it.  The value uses",(0,a.kt)("a",{href:"#range"},"range notation"),".",(0,a.kt)("p",null,"If the stream format is ",(0,a.kt)("code",null,"delimited")," or ",(0,a.kt)("code",null,"csv"),", record length is measured by number of fields.  If the stream format is ",(0,a.kt)("code",null,"fixedlength"),", record length is measured in characters.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"csv, delimited, fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minLength")),(0,a.kt)("td",null,"If the stream format is ",(0,a.kt)("code",null,"delimited")," or ",(0,a.kt)("code",null,"csv"),", ",(0,a.kt)("code",null,"minLength")," is the minimum number of fields required by this record.  If ",(0,a.kt)("code",null,"strict")," is true, defaults to the number of fields defined for the record, otherwise 0.",(0,a.kt)("p",null,"If the stream format is ",(0,a.kt)("code",null,"fixedlength"),", ",(0,a.kt)("code",null,"minLength")," is the minimum number of characters required by this record.  If ",(0,a.kt)("code",null,"strict")," is true, defaults to the sum of all field lengths definied for the record, otherwise 0.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"csv, delimited, fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxLength")),(0,a.kt)("td",null,"If the stream format is ",(0,a.kt)("code",null,"delimited")," or ",(0,a.kt)("code",null,"csv"),", ",(0,a.kt)("code",null,"maxLength")," is the maximum number of fields allowed by this record.  If ",(0,a.kt)("code",null,"strict")," is true, defaults to the number of fields defined for the record, or if no fields are declared or ",(0,a.kt)("code",null,"strict")," is false, then ",(0,a.kt)("code",null,"unbounded"),".",(0,a.kt)("p",null,"If the stream format is ",(0,a.kt)("code",null,"fixedlength"),", ",(0,a.kt)("code",null,"maxLength")," is the maximum number of characters allowed by this record.  If ",(0,a.kt)("code",null,"strict")," is true, defaults to the sum of all field lengths defined for the record, or if no fields are declared or ",(0,a.kt)("code",null,"strict")," is false, then ",(0,a.kt)("code",null,"unbounded"),".")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"csv, delimited, fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlName")),(0,a.kt)("td",null,"The local name of the XML element mapped to this record.  Defaults to the record name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlNamespace")),(0,a.kt)("td",null,"The namespace of the XML element mapped to this record.  Defaults to the namespace declared for this record's parent group or stream."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlPrefix")),(0,a.kt)("td",null,"The namespace prefix assigned to the declared ",(0,a.kt)("code",null,"xmlNamespace")," for marshalling XML. If not specified, the default namespace is used (i.e. ",(0,a.kt)("code",null,'xmlns="..."'),")."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")))),(0,a.kt)("p",null,"Children: ( ",(0,a.kt)("a",{parentName:"p",href:"#field"},(0,a.kt)("inlineCode",{parentName:"a"},"field"))," | ",(0,a.kt)("a",{parentName:"p",href:"#property"},(0,a.kt)("inlineCode",{parentName:"a"},"property"))," | ",(0,a.kt)("a",{parentName:"p",href:"#segment"},(0,a.kt)("inlineCode",{parentName:"a"},"segment"))," | ",(0,a.kt)("a",{parentName:"p",href:"#include"},(0,a.kt)("inlineCode",{parentName:"a"},"include"))," )","*"),(0,a.kt)("h3",{id:"a11-segment"},"A.11. ",(0,a.kt)("inlineCode",{parentName:"h3"},"segment")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"segment")," is used to bind groups of fields to a nested bean object, or to validate repeating groups of fields, or in\nan XML formatted stream, to wrap one or more fields in an element."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Format(s)")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The name of the segment.  If the segment is bound to a bean object, the segment name is used for the name of the bean property unless a ",(0,a.kt)("code",null,"getter")," or ",(0,a.kt)("code",null,"setter"),"is set."),(0,a.kt)("td",null,"Yes"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"class")),(0,a.kt)("td",null,"The fully qualified class name of the bean object bound to this segment. If set to ",(0,a.kt)("code",null,"map")," or any ",(0,a.kt)("code",null,"java.util.Map")," implementation, a Map object will be used with field/segment names for keys and field/segment values for values."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"value"),(0,a.kt)("br",null),(0,a.kt)("del",null,(0,a.kt)("code",null,"target"))),(0,a.kt)("td",null,"The name of a child segment or field to return in lieu of an assigned class. If set, all other descendants are not bound to the parent bean property."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"getter")),(0,a.kt)("td",null,"The getter method used to get the bean object bound to this segment from it's parent. By default, the getter method is determined through introspection using the segment name.  Ignored if ",(0,a.kt)("code",null,"class")," is not set."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"setter")),(0,a.kt)("td",null,"The setter method used to set the bean object bound to this segment on the bean object of it's parent.  By default, the setter method is determined through introspection using the segment name.  Ignored if ",(0,a.kt)("code",null,"class")," is not set."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"collection")),(0,a.kt)("td",null,"The collection type for repeating segments bound to a parent bean object. The value may be set to any fully qualified class name assignable to ",(0,a.kt)("code",null,"java.util.Collection")," or ",(0,a.kt)("code",null,"java.util.Map"),", or to one of the collection type aliases: ",(0,a.kt)("code",null,"list"),", ",(0,a.kt)("code",null,"set"),", ",(0,a.kt)("code",null,"map"),"or ",(0,a.kt)("code",null,"array"),". A collection type can only be set if ",(0,a.kt)("code",null,"class")," or ",(0,a.kt)("code",null,"target")," is also set.",(0,a.kt)("p",null,"BeanIO will not derive the collection type from it's parent bean object."),(0,a.kt)("p",null,'There are a few restrictions specific to repeating segments in any "flat" format (delimited, CSV or fixedlength):'),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Repeating segments must appear in the stream consecutively."),(0,a.kt)("li",null,"A repeating segment cannot contain repeating fields or segments where the length is indeterminate (i.e. where ",(0,a.kt)("code",null,"minOccurs")," does not match ",(0,a.kt)("code",null,"maxOccurs"),")."),(0,a.kt)("li",null,"Repeating segments must fully declare all child fields- there can be no gaps in the definition. (However, you can still skip over unbound values using the ",(0,a.kt)("code",null,"ignore")," field attribute.)"))),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"key")),(0,a.kt)("td",null,"The name of a descendant field to use for the Map key when ",(0,a.kt)("code",null,"collection"),"is assignable to a ",(0,a.kt)("code",null,"java.util.Map"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"The minimum consecutive occurrences of this segment.  Defaults to 1.",(0,a.kt)("p",null,"If ",(0,a.kt)("code",null,"minOccurs")," is 0, a null bean object bound to this segment will not be marshalled (unless a subsequent field is marshalled for CSV, delimited and fixed legnth stream formats)"),(0,a.kt)("p",null,"During unmarshalling, if the configured minimum occurrences is not met, an ",(0,a.kt)("code",null,"InvalidRecordException")," is thrown.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxOccurs")),(0,a.kt)("td",null,"The maximum consecutive occurrences of this segment.  By default,",(0,a.kt)("code",null,"maxOccurs")," is set to ",(0,a.kt)("code",null,"minOccurs")," or 1, whichever is greater. If there is no limit to the number of occurrences, the value may be set to ",(0,a.kt)("code",null,"unbounded"),".",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<p>If set for a CSV, delimited or fixed length stream, the value can only\nexceed <code>minOccurs</code> if the segment appears at the end of a record.  </p>\n<p>Maximum occurrences is not used for validation.  If bounded, the\n  size of a bound collection will not exceed the configured value, and additional occurrences\n  are ignored.</p>\n"))),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occurs")),(0,a.kt)("td",null,"An alternative to specifying both ",(0,a.kt)("code",null,"minOccurs")," and ",(0,a.kt)("code",null,"maxOccurs"),"that uses ",(0,a.kt)("a",{href:"#range"},"range notation"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occursRef")),(0,a.kt)("td",null,"The name of a preceding field in the same record that controls the number of occurrences of this segment.  If the controlling field is not bound to a separate property (i.e. ",(0,a.kt)("code",null,'ignore="true"'),"), its automatically set based on the size of the segment collection during marshalling."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"csv, delimited, fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lazy")),(0,a.kt)("td",null,"If set to ",(0,a.kt)("code",null,"true"),", the class or collection bound to this segment will only be instantiated if at least one child attribute is not null or the empty String. Defaults to ",(0,a.kt)("code",null,"false"),".  This functionality differs from ",(0,a.kt)("code",null,"minOccurs"),"in that the fields may still exist in the input stream."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"template")),(0,a.kt)("td",null,"The name of the template to include.  The template is added to the layout before any child of this segment."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlType")),(0,a.kt)("td",null,"The XML node type mapped to this segment. If not specified or set to ",(0,a.kt)("code",null,"element"),", this bean is mapped to an XML element.  If set to",(0,a.kt)("code",null,"none"),", children of this segment are expected to be contained by this segment's parent."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlName")),(0,a.kt)("td",null,"The local name of the XML element mapped to this segment.  Defaults to the segment name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlNamespace")),(0,a.kt)("td",null,"The namespace of the XML element mapped to this segmnet.  Defaults to the namespace declared for the parent ",(0,a.kt)("a",{href:"#record"},(0,a.kt)("code",null,"record"))," or ",(0,a.kt)("code",null,"segmnet"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlPrefix")),(0,a.kt)("td",null,"The namespace prefix assigned to the declared ",(0,a.kt)("code",null,"xmlNamespace")," for marshalling XML. If not specified, the default namespace is used (i.e. ",(0,a.kt)("code",null,'xmlns="..."'),")."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"nillable")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," if the W3C Schema Instance attribute ",(0,a.kt)("code",null,"nil")," should be set to true when marshalling a null bean object.  Defaults to ",(0,a.kt)("code",null,"false"),".  During unmarshalling, a nillable element will cause an ",(0,a.kt)("code",null,"InvalidRecordException")," if ",(0,a.kt)("code",null,"nillable"),"is false.."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")))),(0,a.kt)("p",null,"Children: ( ",(0,a.kt)("a",{parentName:"p",href:"#field"},(0,a.kt)("inlineCode",{parentName:"a"},"field"))," | ",(0,a.kt)("a",{parentName:"p",href:"#property"},(0,a.kt)("inlineCode",{parentName:"a"},"property"))," | ",(0,a.kt)("a",{parentName:"p",href:"#segment"},(0,a.kt)("inlineCode",{parentName:"a"},"segment"))," | ",(0,a.kt)("a",{parentName:"p",href:"#include"},(0,a.kt)("inlineCode",{parentName:"a"},"include"))," )","*"),(0,a.kt)("h3",{id:"a12-field"},"A.12. ",(0,a.kt)("inlineCode",{parentName:"h3"},"field")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"field")," element is used to bind a field belonging to a record or segment to a bean property."),(0,a.kt)("p",null,"Attributes:"),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Attribute"),(0,a.kt)("th",null,"Description"),(0,a.kt)("th",null,"Required"),(0,a.kt)("th",null,"Formats")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"name")),(0,a.kt)("td",null,"The name of field.  Unless a getter and/or setter is defined, the field name is used for the bean property name."),(0,a.kt)("td",null,"Yes"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"getter")),(0,a.kt)("td",null,"The getter method used to retrieve the property value for this field from its parent bean class.  By default, the getter method is determined through introspection using the field name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"setter")),(0,a.kt)("td",null,"The setter method used to set the property value of this field on its parent bean class. By default, the setter method is determined through introspection using the field name.",(0,a.kt)("p",null,"If the field is a constructor argument, ",(0,a.kt)("code",null,"setter")," may be set to '#N', where N is the position of the argumnet in the constructor beginning at 1.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"rid")),(0,a.kt)("td",null,"Record identifier indicator.  Set to ",(0,a.kt)("code",null,"true")," if this field is used to identify a record. More than one field can be used to identify a record.  Defaults to ",(0,a.kt)("code",null,"false"),".",(0,a.kt)("p",null,"Record identifying fields must have ",(0,a.kt)("code",null,"regex")," or ",(0,a.kt)("code",null,"literal")," configured to match a record, unless the field is a named XML element or attribute.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"at"),(0,a.kt)("br",null),(0,a.kt)("code",null,"position")),(0,a.kt)("td",null,"For delimited and CSV formatted streams, ",(0,a.kt)("code",null,"position")," (or ",(0,a.kt)("code",null,"at"),") is the index of the field within the record, beginning at 0.  And for fixed length formatted streams, ",(0,a.kt)("code",null,"position"),"is the index of the first character of the field within the record, beginning at 0.",(0,a.kt)("p",null,"Negative numbers can be used to indicate the position is relative to the end of the record. For example, the position -2 indicates the second to last field in a delimited record."),(0,a.kt)("p",null,"If the field repeats, or the field belongs to a segment that repeats,",(0,a.kt)("code",null,"position")," should be set based on the first occurrence of the field in a record."),(0,a.kt)("p",null,"A position must be specified for all fields in a record, or for none at all.  If positions are not specified, BeanIO will automatically calculate field positions based on the order in which the fields are defined in the mapping file."),(0,a.kt)("p",null,"Position, if defined, is also used in XML formatted streams for ordering fields within their parent record or segment.  This is typically not needed when using a mapping file, but can be useful when using annotations."),(0,a.kt)("p",null,"If a position is configured for a parent segment (with annotations), the positions declared for fields added to the segment are assumed to be relative to their parent.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"until")),(0,a.kt)("td",null,"The maximum position of the field in the record.  Only applies to fields that repeat where the number of occurrences is indeterminate (i.e. ",(0,a.kt)("code",null,"maxOccurs")," is greater than ",(0,a.kt)("code",null,"minOccurs"),").  ",(0,a.kt)("code",null,"until")," must always be specified relative to the end of the record, and is therefore always a negative number."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"csv, delimited, fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"trim")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," to trim the field text before validation and type conversion.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lazy")),(0,a.kt)("td",null,"Set to true to convert empty field text to null before type conversion.  For repeating fields bound to a collection, the collection will not be created if all field values are null or the empty String.  Defaults to false."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"required")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," if this field is required.  If a field is required and its field text is empty, a ",(0,a.kt)("code",null,"BeanReader")," will throw an ",(0,a.kt)("code",null,"InvalidRecordException")," when reading the record.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minLength")),(0,a.kt)("td",null,"The minimum length of the field text before type conversion.  Minimum length is only validated if the field length is greater than 0.  Defaults to 0."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxLength")),(0,a.kt)("td",null,"The maximum length of the field text before type conversion.  Defaults to ",(0,a.kt)("code",null,"unbounded"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"regex")),(0,a.kt)("td",null,"The regular expression pattern the field text must match."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"literal")),(0,a.kt)("td",null,"Sets the ",(0,a.kt)("i",null,"literal")," or constant value of this field.  When unmarshalled, an ",(0,a.kt)("code",null,"InvalidRecordException")," is thrown if the field text does not exactly match the literal value."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"default")),(0,a.kt)("td",null,"The default value of this field.",(0,a.kt)("p",null,"When unmarshalling a stream, this value is set on the bean object when the field text is null or the empty string.  And when marshalling, the default value is used when the property value is null or ignore is set to",(0,a.kt)("code",null,"true")," (unless disabled)."),(0,a.kt)("p",null,"A default value is converted to a Java object using the same type handler configured for the field.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"type")),(0,a.kt)("td",null,"The fully qualified class name or type alias of the field value.  By default, BeanIO will derive the field type from its parent bean class.  This attribute can be used to override the default, or may be needed when its parent class is of type ",(0,a.kt)("code",null,"java.util.Map"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"collection")),(0,a.kt)("td",null,"If a repeating field is bound to a collection object, ",(0,a.kt)("code",null,"collection"),"is the fully qualified class name of the ",(0,a.kt)("code",null,"java.util.Collection")," implementation, or a collection type alias.  When a ",(0,a.kt)("code",null,"collection")," is configured, the ",(0,a.kt)("code",null,"type")," attribute is used to declare the property type of an item stored in the collection. May be set to ",(0,a.kt)("code",null,"array")," if the collection type is a Java array.",(0,a.kt)("p",null,"Repeating fields bound to a property value must have ",(0,a.kt)("code",null,"collection")," configured. BeanIO will not derive the collection type from a field's parent bean class.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"The minimum consecutive occurrences of this field in a record.  Defaults to 1, with one exception: a field in an XML formatted stream bound to an attribute defaults to 0.",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<p><code>minOccurs</code> controls whether a field is marshalled for a null field value, and\n whether the field must be present during unmarshalling.  If <code>minOccurs</code> is 1 or\n greater and the field is not present during unmarshalling, an <code>InvalidRecordException</code> is thrown.</p>\n"))),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"maxOccurs")),(0,a.kt)("td",null,"The maximum consecutive occurrences of this field in a record.  By default,",(0,a.kt)("code",null,"maxOccurs")," is set to ",(0,a.kt)("code",null,"minOccurs")," or 1, whichever is greater.  If overridden for a non-XML stream format, the value can only exceed ",(0,a.kt)("code",null,"minOccurs")," if this is the last field in the record.  The value may be set to ",(0,a.kt)("code",null,"unbounded")," if there is no limit to the number of occurrences of this field.",(0,a.kt)("p",null,"Maximum occurrences is not used for validation. When bounded, the size of a collection will not exceed the configured value, and additional occurrences are ignored.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occurs")),(0,a.kt)("td",null,"An alternative to specifying both ",(0,a.kt)("code",null,"minOccurs")," and ",(0,a.kt)("code",null,"maxOccurs"),"that uses ",(0,a.kt)("a",{href:"#range"},"range notation"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"occursRef")),(0,a.kt)("td",null,"The name of a preceding field in the same record that controls the number of occurrences of this field.  If the controlling field is not bound to a separate property (i.e. ",(0,a.kt)("code",null,'ignore="true"'),"), its automatically set based on the size of the field collection during marshalling."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"csv, delimited, fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"format")),(0,a.kt)("td",null,"The decimal format pattern for ",(0,a.kt)("code",null,"java.lang.Number")," field values, or the simple date format pattern for ",(0,a.kt)("code",null,"java.util.Date")," field properties.",(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,"format")," value can also be accessed by any custom type handler that implements ",(0,a.kt)("code",null,"org.beanio.types.ConfigurableTypeHandler"),".")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"typeHandler")),(0,a.kt)("td",null,"The name of the type handler to use for type conversion.  By default, BeanIO will select a type handler based on the field type when set, or through introspection of this field's parent bean class."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"ignore")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," if this field is not a property of it's parent bean class. Defaults to ",(0,a.kt)("code",null,"false"),".  Note that any configured validation rule on an ignored field is still performed."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"*")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"length")),(0,a.kt)("td",null,"The padded length of this field measured in characters.  Length is required for fixed length formatted streams, and can be set for fields in other stream formats (along with a padding character) to enable field padding.",(0,a.kt)("p",null,"The length of the last field in a fixed length record may be set to ",(0,a.kt)("code",null,"unbounded"),"to disable padding and allow a single variable length field at the end of the otherwise fixed length record.")),(0,a.kt)("td",null,"Yes",(0,a.kt)("sup",null,"1")),(0,a.kt)("td",null,(0,a.kt)("code",null,"*"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"padding")),(0,a.kt)("td",null,"The character used to pad this field.  For fixed length formatted streams,",(0,a.kt)("code",null,"padding")," defaults to a space.  For non-fixed length formatted streams, padding is disabled unless a padding character and length are specified.",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<p>If padding is enabled, the <code>required</code> field attribute has some control over the\nmarshalling and unmarshalling of null values.</p>\n\n<p>When unmarshalling a field consisting of all spaces in a fixed length stream,\nif <code>required</code> is false, the field\nis accepted regardless of the padding character.  If\n<code>required</code> is true, a required field validation error is triggered.  And when\nmarshalling a null field value, if <code>required</code> is false,\nthe field text is formatted as spaces regardless of the configured padding character.\n</p>\n\n<p>In other stream formats that are not fixed length, null field values are\nunmarshalled and marshalled as empty strings when <code>required</code> is false.\nWhen <code>required</code> is true, unmarshalling an empty string will trigger a required\nfield validation error, and marshalling a null value will fill the field text with\nthe padding character up to the padded length of the field.</p>\n"))),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,(0,a.kt)("code",null,"*"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"keepPadding")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," if field padding should not be removed when unmarshalling a fixed length field.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"lenientPadding")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," to disable enforcement of the padded field length when unmarshalling a fixed length field.  Defaults to ",(0,a.kt)("code",null,"false"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"fixedlength")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"justify",(0,a.kt)("br",null),"align")),(0,a.kt)("td",null,"The justification (i.e. alignment) of the field text within its padding.  Either",(0,a.kt)("code",null,"left")," or ",(0,a.kt)("code",null,"right"),".  Defaults to ",(0,a.kt)("code",null,"left"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,(0,a.kt)("code",null,"*"))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlType")),(0,a.kt)("td",null,"The XML node type mapped to this field.  The type can be set to ",(0,a.kt)("code",null,"element")," (default) to map this field to an XML element, ",(0,a.kt)("code",null,"attribute")," to map to an XML attribute, or ",(0,a.kt)("code",null,"text"),"to map the field value to the enclosed text of it's parent record or segment.",(0,a.kt)("p",null,"When set to ",(0,a.kt)("code",null,"text"),", ",(0,a.kt)("code",null,"xmlName")," and ",(0,a.kt)("code",null,"xmlNamespace")," have no effect.")),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlName")),(0,a.kt)("td",null,"The local name of the XML element or attribute mapped to this field.  Defaults to the field name."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlNamespace")),(0,a.kt)("td",null,"The namespace of the XML element mapped to this field.  Defaults to the namespace configured for it's immediate parent record or segment."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"xmlPrefix")),(0,a.kt)("td",null,"The namespace prefix assigned to the configured ",(0,a.kt)("code",null,"xmlNamespace")," for marshalling XML. If not specified, the default namespace (i.e. ",(0,a.kt)("code",null,'xmlns="..."'),") is used."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"nillable")),(0,a.kt)("td",null,"Set to ",(0,a.kt)("code",null,"true")," if the W3C Schema Instance attribute ",(0,a.kt)("code",null,"nil")," should be set to true when the marshalled field value is null.  Defaults to ",(0,a.kt)("code",null,"false"),". Unmarshalling a non-nillalbe field where ",(0,a.kt)("code",null,'nil="true"')," will cause an",(0,a.kt)("code",null,"InvalidRecordException"),"."),(0,a.kt)("td",null,"No"),(0,a.kt)("td",null,"xml")))),(0,a.kt)("p",null,"\xa0",(0,a.kt)("sup",null,"1"),"Only required for fixed length fields. If a literal value is supplied for a fixed length field, ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," will default\nto the length of the literal value."),(0,a.kt)("h2",{id:"appendix-b-error-message-parameters"},"Appendix B: Error Message Parameters"),(0,a.kt)("p",null,"The following table shows the message parameters used to format an error message for each configurable validation rule."),(0,a.kt)("table",null,(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"Type"),(0,a.kt)("th",null,"Rule Name"),(0,a.kt)("th",null,"Index"),(0,a.kt)("th",null,"Value")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"12"},"Record Error"),(0,a.kt)("td",null,(0,a.kt)("code",null,"malformed")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("code",null,"unidentified")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"2"},(0,a.kt)("code",null,"unexpected")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"4"},(0,a.kt)("code",null,"minLength")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Minimum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Maximum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"4"},(0,a.kt)("code",null,"maxLength")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Minimum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Maximum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"52"},"Field Error"),(0,a.kt)("td",{rowSpan:"4"},(0,a.kt)("code",null,"required")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"4"},(0,a.kt)("code",null,"nillable")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"6"},(0,a.kt)("code",null,"minLength")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Minimum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"5"),(0,a.kt)("td",null,"Maximum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"6"},(0,a.kt)("code",null,"maxLength")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Minimum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"5"),(0,a.kt)("td",null,"Maximum Length")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("code",null,"length")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Fixed Length Field Length")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("code",null,"regex")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Regular Expression Pattern")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("code",null,"type")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,(0,a.kt)("code",null,"TypeConversionException")," error message.")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"5"},(0,a.kt)("code",null,"literal")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"Field Text")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Literal value")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"6"},(0,a.kt)("code",null,"minOccurs")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field or Bean Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"-")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Minimum occurrences")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"5"),(0,a.kt)("td",null,"Maximum occurences")),(0,a.kt)("tr",null,(0,a.kt)("td",{rowSpan:"6"},(0,a.kt)("code",null,"maxOccurs")),(0,a.kt)("td",null,"0"),(0,a.kt)("td",null,"Line Number")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"1"),(0,a.kt)("td",null,"Record Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"2"),(0,a.kt)("td",null,"Field or Bean Label/Name")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"3"),(0,a.kt)("td",null,"-")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"4"),(0,a.kt)("td",null,"Minimum occurrences")),(0,a.kt)("tr",null,(0,a.kt)("td",null,"5"),(0,a.kt)("td",null,"Maximum occurences")))),(0,a.kt)("h2",{id:"appendix-c-upgrading-a-1x-mapping-file-example"},"Appendix C: Upgrading a 1.x Mapping File Example"),(0,a.kt)("p",null,"This appendix illustrates typical changes required to update an 1.x mapping file to 2.x."),(0,a.kt)("p",null,"Given the following 1.x mapping file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<beanio xmlns="http://www.beanio.org/2011/01"\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xsi:schemaLocation="http://www.beanio.org/2011/01 http://www.beanio.org/2011/01/mapping.xsd">\n\n    <stream name="employees" format="delimited">\n        <reader>\n            <property name="delimiter" value="," />\n        </reader>\n        <writer>\n            <property name="delimiter" value="," />\n        </writer>\n        <record name="header" class="example.Header" maxOccurs="1">\n            <field name="recordType" rid="true" literal="H" />\n            <field name="fileDate" format="yyyy-MM-dd" />\n        </record>\n        <record name="employee" class="example.Employee" minOccurs="0" minLength="6" maxLength="7">\n            <field name="recordType" rid="true" literal="D" />\n            <field name="firstName" />\n            <field name="lastName" />\n            <bean name="address" class="example.Address" >\n                <field name="city" />\n                <field name="state" />\n                <field name="zip" />\n            </bean>\n            <field name="phoneNumber" />\n        </record>\n        <record name="trailer" class="example.Trailer" maxOccurs="1">\n            <field name="recordType" rid="true" literal="T" />\n            <field name="recordCount" />\n        </record>\n    </stream>\n\n    <stream name="contacts" format="xml" ordered="false">\n        <record name="person" class="example.Person" minOccurs="0">\n            <field name="firstName" />\n            <field name="lastName" minOccurs="1" />\n            <field name="phone" collection="list" minOccurs="0" maxOccurs="5" xmlWrapper="phoneList" />\n        </record>\n        <record name="company" class="example.Person" minOccurs="0">\n            <field name="companyName" minOccurs="1" />\n            <field name="phone" />\n        </record>\n    </stream>\n\n</beanio>\n')),(0,a.kt)("p",null,"The following 2.x mapping file can be created:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'\x3c!-- Namespace updated --\x3e\n<beanio xmlns="http://www.beanio.org/2012/03"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd">\n\n  \x3c!-- Use \'strict\' to have BeanIO calculate and enforce default record lengths and ordering --\x3e\n  <stream name="employees" format="delimited" strict="true">\n    \x3c!-- Combine \'reader\' and \'writer\' elements into \'parser\' --\x3e\n    <parser>\n      <property name="delimiter" value="," />\n    </parser>\n    \x3c!-- \'minOccurs\' defaults to 0 if not specified --\x3e\n    <record name="header" class="example.Header" minOccurs="1" maxOccurs="1">\n      <field name="recordType" rid="true" literal="H" />\n      <field name="fileDate" format="yyyy-MM-dd" />\n    </record>\n    \x3c!-- \'minLength/maxLength\' not needed, see \'phoneNumber\' field below for explanation --\x3e\n    <record name="employee" class="example.Employee" minOccurs="0" minLength="6" maxLength="7">\n      <field name="recordType" rid="true" literal="D" />\n      <field name="firstName" />\n      <field name="lastName" />\n      \x3c!-- Change \'bean\' elements to \'segment\' elements --\x3e\n      <segment name="address" class="example.Address" >\n        <field name="city" />\n        <field name="state" />\n        <field name="zip" />\n      </segment>\n      \x3c!-- Use \'minOccurs\' to denote optional fields at the end of a record.  When used with\n        -- \'strict\', there is no need to set \'minLength\' and \'maxLength\' on the record, unless\n        -- you are not mapping every field --\x3e\n      <field name="phoneNumber" minOccurs="0" />\n    </record>\n    <record name="trailer" class="example.Trailer" minOccurs="1" maxOccurs="1">\n      <field name="recordType" rid="true" literal="T" />\n      <field name="recordCount" />\n    </record>\n  </stream>\n\n  \x3c!-- Records are not ordered by default.  --\x3e\n  <stream name="contacts" format="xml" ordered="false">\n    \x3c!-- minOccurs defaults to 0 --\x3e\n    <record name="person" class="example.Person" minOccurs="0">\n      \x3c!-- Optional XML elements must set minOccurs to 0 --\x3e\n      <field name="firstName" minOccurs="0"/>\n      <field name="lastName" minOccurs="1" />\n      \x3c!-- Use a \'segment\' instead of an \'xmlWrapper\' --\x3e\n      <segment name="phoneList" minOccurs="0">\n        <field name="phone" collection="list" minOccurs="0" maxOccurs="5" xmlWrapper="phoneList" />\n      </segment>\n    </record>\n    <record name="company" class="example.Person" minOccurs="0">\n      <field name="companyName" minOccurs="1" />\n      \x3c!-- Optional XML elements must set minOccurs to 0 --\x3e\n      <field name="phone" minOccurs="0"/>\n    </record>\n  </stream>\n\n</beanio>\n')))}m.isMDXComponent=!0}}]);